### HTTP 메시지 헤더

![스크린샷 2023-09-04 오후 4.32.07](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 4.32.07.png)

HTTP 프로토콜의 리퀘스트와 리스폰스에는 반드시 메시지 헤더가 포함되어 있는데 메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보가 들어 있습니다. 이러한 정보의 대부분은 클라이언트를 이용하는 사용자가 직접 볼 필요는 없습니다. 메시지 헤더는 몇 가지의 요소로 구성되어 있습니다.

**리퀘스트의 HTTP 메시지**

메소드, URI, HTTP 버전, HTTP 헤더 필드 등으로 구성되어 있습니다.

![스크린샷 2023-09-04 오후 4.40.22](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 4.40.22.png)

**리스폰스의 HTTP 메시지**

HTTP 메시지와 HTTP 버전, 상태 코드(코드와 설명), HTTP 헤더 필드 등으로 구성되어 있습니다.

![스크린샷 2023-09-04 오후 4.41.14](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 4.41.14.png)

리퀘스트/리스폰스 메시지의 메시지 헤더의 요소 중에서 가장 다양한 정보를 가지고 있는 것이 HTTP 헤더 필드입니다. 헤더 필드는 HTTP 메시지에 관한 정보를 가지고 있습니다. 헤더 필드는 HTTP 버전과 확장 사양에 따라서 지원하는 내용이 달라지지만, 이번 장에서는 주로 HTTP/1.1과 일반적으로 자주 사용되고 있는 부분에 대해서 다룹니다.

### HTTP 헤더 필드

**HTTP 헤더 필드는 중요한 정보를 전달한다**

HTTP 헤더 필드는 HTTP 메시지를 구성하는 요소의 하나입니다. 헤더 필드는 HTTP 프로토콜 중에서 클라이언트와 서버간의 통신에서 리퀘스트에도 리스폰스에도 사용되고 있고, 부가적으로 중요한 정보를 전달하는 역할을 담당하고 있습니다. 그리고 메시지 바디의 크기나 사용하고 있는 언어, 인증 정보 등을 브라우저나 서버에 제공하기 위해 사용되고 있습니다.

**HTTP 헤더 필드의 구조**

HTTP 헤더 필드는 헤더 필드 명과 필드 값으로 구성되어 있고 콜론":" 으로 나뉘어져 있습니다.

```
헤더 필드 명 : 필드 값
```

예를 들면, 메시지 바디의 오브젝트 타입을 가리키는 Content-Type이라는 HTTP 헤더 필드가 포함되어 있습니다.

```
Content-Type:text/html
```

이 경우, "Content-Type"이 헤더 필드 명이고 문자열 "text/html"이 필드 값이 됩니다. 또한, 다음과 같이 하나의 HTTP 헤더 필드가 여러 개의 필드 값을 가질 수 있습니다.

```
Keep-Alive:timeout=15,max=100
```

![스크린샷 2023-09-04 오후 4.48.24](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 4.48.24.png)

**4종류의 HTTP 헤더 필드**

HTTP 헤더 필드는 그 용도에 따라 다음과 같이 4종류로 분류됩니다.

*일반적 헤더 필드(General Header Fields)*

​	리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더입니다.

*리퀘스트 헤더 필드(Request Header Fields)*

​	클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로 리	퀘스트의 부가적 정보와 클라이언트의 정보, 리스폰스의 콘텐츠에 관한 우선 순	위 등을 부가합니다.

*리스폰스 헤더 필드(Respose Header Fields)*

​	서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더로 리	스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가합니다.

*엔티티 헤더 필드(Entity Header Fields)*

​	리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐	츠 갱신 시간 등의 엔티티에 관한 정보를 부가합니다.

**HTTP/1.1 헤더 필드 일람**

HTTP/1.1에 정의되어 있는 헤더 필드에는 다음과 같이 47종류가 있습니다.

![스크린샷 2023-09-04 오후 4.53.13](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 4.53.13.png)

<hr>

![스크린샷 2023-09-04 오후 4.53.34](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 4.53.34.png)

<hr>

![스크린샷 2023-09-04 오후 4.53.44](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 4.53.44.png)

![스크린샷 2023-09-04 오후 4.53.57](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 4.53.57.png)

<hr>

![스크린샷 2023-09-04 오후 4.54.09](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 4.54.09.png)

<hr>

**HTTP/1.1 이외의 헤더 필드**

HTTP에서 교환되는 HTTP 헤더 필드가 RFC2616에서 정의된 47종류만 있는 것은 아닙니다. 예를 들면, 쿠키와 Set-Cookie, Content-Disposition와 같이, 그 외에 RFC에 정의되어 폭 넓게 사용되고 있는 것도 있습니다. 이러한 비표준 헤더 필드는 RFC4229 HTTP Header Field Registrations에 정리되어 있습니다.

**End-to-end 헤더와 Hop-by-hop 헤더**

HTTP 헤더 필드는 캐시와 비캐시 프록시의 동작을 정의하기 위해서 두 가지 카테고리로 분류되어 있습니다.

*End-to-end*

​	이 카테고리에 분류된 헤더는 리퀘스트나 리스폰스의 최종 수신자에게 전송됩	니다. 캐시에서 구축된 리스폰스 중 보존되야 하고, 다시 전송되지 않으면 안되	도록 되어 있습니다.

*Hop-by-hop*

​	이 카테고리에 분류된 헤더는 한 번 전송에 대해서만 유효하고 캐시와 프록시에 의해서 전송되지 않는 것도 있습니다. HTTP/1.1과 그 이후에서 사용되는 Hop-by-hop 헤더는 Connection 헤더 필드에 열거해야 합니다.

HTTP/1.1에서 hop-by-hop 헤더에는 다음과 같은 것이 있습니다. 여기에서 열거하는 8개의 헤더 필드 이외에는 모두 End-by-end 헤더에 분류됩니다.

- Connection
- Keep-Alive
- Proxy-Authenticate
- Proxy-Authorization
- Trailer
- TE
- Transfer-Encoding
- Upgrade

**HTTP/1.1 일반 헤더 필드**

일반 헤더 필드는 리퀘스트 메시지와 리스폰스 메시지 양쪽에서 사용되는 헤더입니다.

**Cache-Control**

Cache-Control 헤더는 디렉티브로 불리는 명령을 사용하여 캐싱 동작을 지정합니다.

![스크린샷 2023-09-04 오후 11.53.32](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-04 오후 11.53.32.png)

지정한 디렉티브에는 파라미터가 있는 것과 없는 것도 있으며 여러 개의 디렉티브를 징하느 경우에는 콤마","로 구분합니다. Cache-Control 헤더 필드의 디렉티브는 리퀘스트 및 리스폰스 할 때에 사용할 수 있습니다.

```
Cache-Control: private, max-age=0, no-cache
```

- Cache-Control 디렉티브 일람

  사용 가능한 디렉티브를 리퀘스트와 리스폰스로 나눠서 다음과 같이 나타냅니다.

  ![스크린샷 2023-09-05 오전 12.34.26](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-05 오전 12.34.26.png)

  <hr>

![스크린샷 2023-09-05 오전 12.34.43](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-05 오전 12.34.43.png)

**캐시가 가능한지 여부를 나타내는 디렉티브**

1. public 디렉티브

   ```
   Cache-Control: public
   ```

   다른 유저에게도 돌려줄 수 있는 캐시를 해도 좋다는 것을 명시적으로 나타냅니다.

2. private 디렉티브

   ```
   Cache-Control: private
   ```

   리스폰스는 특정 유저만을 대상으로 하고 있다는 것을 나타냅니다. Public 디렉티브와 기능이 반대입니다. 캐시 서버는 특정 유저를 위해서 리소스를 캐시할 수 있지만, 다른 유저로부터 같은 리퀘스트가 온다고 하더라도 그 캐시를 반환하지 않도록 합니다.

3. no-cache 디렉티브

   ```
   Cache-Control: no-cache
   ```

   캐시로부터 오래된 리소스가 반환되는 것을 막기 위해 사용됩니다. 클라이언트의 리퀘스트로 no-cache 디렉티브가 사용된 경우, 캐시된 리스폰스를 클라이언트가 받아 들이지 않음을 나타냅니다. 즉, 중간 캐시 서버가 오리진 서버까지 리퀘스트를 전송해야 합니다. 서버의 리스폰스에 no-cache가 사용된 경우, 캐시 서버는 리소스를 저장할 수가 없습니다. 오리진 서버는 캐시 서버가 이후의 리퀘스트에서 리소스의 유효성을 재확인하지 않고는 그 리스폰스를 사용하지 못하도록 합니다.
   
   ```
   Cache-Control: no-cache=Location
   ```
   
   서버의 리스폰스로 no-cache의 필드 값에 헤더 필드 명이 지정된 경우에는 이 지정된 헤더 필드만 캐시할 수 없습니다. 즉, 지정된 헤더 필드 이외에는 캐시하는 것이 가능합니다. 이 파라미터는 리스폰스 디렉티브만 사용할 수 있습니다.

**캐시로 보존 가능한 것을 제어하는 디렉티브**

1. No-store 디렉티브

   ```
   Cache-Control: no-store
   ```

   no-store 디렉티브가 사용된 경우, 리퀘스트(그와 대응되는 리스폰스) 혹은 리스폰스에 기밀 정보가 포함되어 있음을 나타냅니다. 그렇기 때문에 캐시는 리퀘스트, 리스폰스의 일부분을 로컬 스토리지에 보존해서는 안 되도록 지정합니다.

**캐시 기한이나 검증을 지정하는 디렉티브**

1. s-maxage 디렉티브

   ```
   Cache-Control: s-maxage-604800 (단위 : 초)
   ```

   s-maxage 디렉티브의 기능은 max-age 디렉티브와 동일한데 다른 점은 여러 유저가 이용 할 수 있는 공유 캐시 서버에만 적용된다는 것입니다. 즉, 같은 유저에 반복해서 리스폰스를 반환하는 캐시 서버는 무효한 디렉티브입니다. 또한, s-maxage 디렉티브가 사용되는 경우, Expires 헤더 필드와 max-age 디렉티브는 무시됩니다.

2. max-age 디렉티브

   ```
   Cache-Control: max-age=604800 (단위 : 초)
   ```

   클라이언트의 리퀘스트로 max-age 디렉티브가 사용되었다면 지정되었던 값보다 새로운 경우에는 캐시되었던 리소스를 받아들일 수 있습니다. 또한, 지정된 값이 0이면 캐시 서버는 리퀘스트를 항상 오리진 서버에 넘길 필요가 있습니다. 서버의 리스폰스에서 max-age 디렉티브가 사용되는 경우, 캐시 서버가 유효성의 재확인을 하지 않고 리소스를 캐시에 보존해 두는 최대 시간을 나타냅니다. HTTP/1.1 캐시 서버는 동시에 Expires 헤더 필드가 달린 경우에는 max-age 디렉티브의 지정을 우선하고 Expires 헤더 필드를 무시합니다. HTTP/1.0 캐시 서버는 반대로 max-age 디렉티브가 무시됩니다.

3. min-fresh 디렉티브

   ```
   Cache-Control: min-fresh=60 (단위 : 초)
   ```

   min-fresh 디렉티브가 사용되는 경우, 캐시된 리소스가 적어도 지정된 시간은 최신 상태의 것을 반환하도록 캐시 서버에 요구합니다. 예를 들면, 60초로 지정되어 있는 경우에는 60초 이내에 유효 기한이 끝나는 리소스를 리스폰스로 반환하면 안됩니다.

1. max-stale 디렉티브

   ```
   Cache-Control: max-stale=3600 (단위 : 초)
   ```

   max-stale 디렉티브가 사용되는 경우, 캐시된 리소스의 유효 기한이 끝났더라도 받아들일 수 있음을 나타냅니다. 디렉티브에 값이 지정되어 있지 않는 경우는 클라이언트는 아무리 시간이 경과했더라도 리스폰스를 받아 들입니다. 값이 지정되어 있는 경우에는 유효 기한이 지난 후로부터 지정 시간 내라면 받아 들인다는 뜻을 서버에 전달합니다.

2. only-if-cached 디렉티브

   ```
   Cache-Control: only-if-cached
   ```

   only-if-cached 디렉티브가 사용되는 경우, 클라이언트는 캐시 서버에 대해서 목적한 리소스가 로컬 캐시에 있는 경우만 리스폰스를 반환하도록 요구합니다. 즉, 캐시 서버에서 리스폰스의 리로드와 유효성을 재확인하지 않도록 요구합니다. 캐시 서버가 로컬 캐시로부터 응답할 수 없는 경우에는 "504 Gateway Timeout" 상태를 반환합니다.

3. must-revalidate 디렉티브

   ```
   Cache-Control: must-revalidate
   ```

   must-revalidate 디렉티브가 사용되는 경우, 리스폰스의 캐시가 현재도 유효한지 아닌지의 여부를 오리진 서버에 조회를 요구합니다. 프록시가 오리진 서버에 도달할 수 없고, 리소스를 다시 요구할 수 없는 경우에는 캐시는 클라이언트에 504(Gateway Timeout)를 반환합니다. 또한, must-revalidate 디렉티브가 사용되는 경우, 리퀘스트에서 max-stale 디렉티브를 사용하고 있더라도 무시합니다(효과를 없앱니다).

4. proxy-revalidate 디렉티브

   ```
   Cache-Control: proxy-revalidate
   ```

   proxy-revalidate 디렉티브가 사용되는 경우, 모든 캐시 서버에 대해서 이후의 리퀘스트로 해당 리스폰스를 반환할 때는 반드시 유효성 재확인을 하도록 요구합니다.

5. no-transform 디렉티브

   ```
   Cache-Control: no-transform
   ```

   no-transform 디렉티브가 사용되는 경우, 리퀘스트와 리스폰스의 어느 쪽에 있어서도 캐시가 엔티티 바디의 미디어 타입을 변경하지 않도록 지정합니다. 이렇게 해서 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지합니다.

**Cache-Control 확장**

1. cache-extension 토큰

   ```
   Cache-Control: private, community="UCI"
   ```

   Cache-Control 헤더 필드는 cache-extension 토큰을 사용하여 디렉티브를 확장할 수 있습니다. 이 예와 같이 community라는 디렉티브는 Cache-Control 헤더 필드에는 없지만 extension tokes에 의해서 추가할 수 있습니다. 만약 캐시 서버가 새로운 디렉티브 "community"를 이해하지 못할 경우에는 무시됩니다. Extension tokens는 이해할 수 있는 캐시 서버에 대해서만 의미가 있습니다.

### Connection

Connection 헤더 필드는 다음의 두 가지 역할을 합니다.

- 프록시에 더 이상 전송하지 않는 헤더 필드를 지정

  ```
  Connection: 더 이상 전송하지 않는 헤더 필드 명
  ```

  클라이언트의 리퀘스트 혹은 서버의 리스폰스에서 Connection 헤더 필드를 사용하며 프록시 서버에 더 이상 전송하지 않는 헤더 필드(hop-by-hop 헤더)를 지정할 수 있습니다.

- 지속적 접근 관리

  ```
  Connection: Close
  ```

  HTTP/1.1에서는 지속적 접속이 디폴트로 되어 있습니다. 그래서 리퀘스트를 송신했던 클라이언트는 접속이 계속 유지되면서 추가 리퀘스트를 송신하도록 합니다. 서버 측에서 명시적으로 접속을 끊고 싶을 경우에는 Connection 헤더 필드에 Close라고 지정합니다.

  ```
  Connection: Keep-Alive
  ```

  하지만 HTTP/1.1 이전 버전의 HTTP에서는 지속적 접속이 디폴트가 아니었습니다. 그렇기 때문에 오래된 버전의 HTTP에서 지속적 접속을 하고 싶은 경우에는 Connection 헤더 필드에 Keep-Alive 라고 지정해야 합니다.

### Date

Date 헤더 필드는 HTTP 메시지를 생성한 날짜를 나타냅니다.

HTTP/1.1에서는 RFC1123에 다음과 같이 날짜 포맷이 지정되어 있습니다.

```
Date: Tue, 03 Jul 2012 04:40:59 GMT
```

오래된 버전의 HTTP에서는 RFC850에 정의된 다음과 같은 포맷을 사용합니다.

```
Date: Tue, 03-Jul-12 04:40:59 GMT
```

이 외에도 다음과 같은 포맷이 있습니다. 이것은 표준 C 라이브러리에 포함되어 있는 asctime() 함수의 출력 형식과 같습니다.

```
Date: Tue Jul 03 04:40:59 2012
```

### Pragma

Pragma 헤더 필드는 HTTP/1.1 보다 오래된 버전의 흔적으로 HTTP/1.0 와의 후방 호환성만을 위해서 정의되어 있는 헤더 필드입니다.

지정할 수 있는 형식은 다음과 같이 1개뿐입니다.

```
Pragma: no-cache
```

이 헤더 필드는 일반 헤더 필드이지만 클라이언트의 리퀘스트에서만 사용됩니다. 클라이언트는 캐시된 리소스의 리스폰스를 원하지 않음을 모든 중간 서버에 알리기 위해 사용됩니다.

모든 중간 서버가 HTTP/1.1을 기준으로 구성되어 있다면 캐시 동작 지정은 Cache-Control: no-cache를 사용하는 것이 바람직하지만, 중간 서버의 HTTP 버전을 모두 파악한 후에 리퀘스트를 보내는 일은 현실적으로 없습니다. 그렇기 때문에 아래와 같이 양쪽을 보내는 경우도 있습니다.

```
Cache-Control: no-cache
Pragma: no-cache
```

### Trailer

Trailer 헤더 필드는 메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달할 수 있습니다. 이 헤더 필드는 HTTP/1.1에 구현되어 있는 청크 전송 인코딩을 사용하고 있는 경우에 사용 가능합니다.

```
HTTP/1.1 200 OK
Date: Tue, 03, Jul 2012 04:40:59 GMT
Content-Type: text/html
...
Transfer-Encoding: chunked
Trailer: Expires

...(메시지 바디)...
0
Expires: Tue, 28 Sep 2004 23:59:59 GMT
```

이 예에서는 Trailer 헤더 필드에 Expires를 지정하고 있고, 메시지 바디의 뒤(청크의 길이가 0의 뒤)에 Expires 헤더 필드가 나타나고 있습니다.

### Transfer-Encoding

Transfer-Encoding 헤더 필드는 메시지 바디의 전송 코딩 형식을 지정하는 경우에 사용됩니다.

HTTP/1.1에서 전송 코딩 형식으로 청크 전송만이 정의되어 있습니다.

```
HTTP/1.1 200 OK
Date: Tue, 03, Jul 2012 04:40:59 GMT
Cache-Control: public, max-age=604800
Content-Type: text/javascript: charset=utf-8
Expires: Tue, 10 Jul 2012 04:40:59 GMT
X-Frame-Options: Deny
X-XSS-Protection: 1: mode=block
Content=Encoding: gzip
Transfer-Encoding: chunked
Connection: keep-alive

CIO		←16진수(10진수로 3312)
3312bytes 정도의 chunk 데이터
392		←16진수(10진수로 914)
914bytes 정도의 chunk 데이터 0
```

이 예의 경우, Transfer-Encoding 헤더 필드로 지정한 것처럼 청크 전송 코딩이 유효한 상태이고 3,312 bytes와 912 bytes의 청크 데이터로 분할되어 있는 것을 알 수 있습니다.

### Upgrade

Upgrade 헤더 필드는 HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용되는 경우에 사용됩니다. 지정하는 대상이 전혀 다른 통신 프로토콜이라고 하더라도 문제 없습니다.

![스크린샷 2023-09-06 오후 5.54.11](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-06 오후 5.54.11.png)

이 예의 경우, Upgrade 헤더 필드에 TLS/1.0가 지정되어 있습니다. 여기서 양쪽 모두 Connection 헤더 필드가 지정되어 있는 점에 주목해 주세요. Upgrade 헤더 필드에 의해서 업그레이드 되는 대상은 클라이언트와 인접한 서버 사이뿐이기 때문에 Upgrade 헤더 필드를 사용하는 경우는 Connection:Upgrade도 지정할 필요가 있습니다. Upgrade 헤더 필드가 달린 리퀘스트에 대해서 서버는 상태 코드 101 Switching Protocols 이라는 리스폰스로 응답할 수 있습니다.

### Via

Via 헤더 필드는 클라이언트와 서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서 사용됩니다. 프록시 혹은 게이트웨이는 자신의 서버 정보를 Via 헤더 필드에 추가한 뒤에 메시지를 전송합니다. 이것은 traceroute와 메일의 Received 헤더의 기능과 유사합니다. Via 헤더 필드는 전송된 메시지의 추적과 리퀘스트 루프의 회피 등에 사용되기 때문에 프록시를 경유하는 경우에는 반드시 부가할 필요가 있습니다. 이 Via 헤더는 배송 경로를 알기 위해 TRACE 메소드와 연계해서 자주 사용됩니다 예를 들면, 프록시 서버에 "Max-Forwards: 0"의 TRACE 리퀘스트가 도달했을 때, 프록시 서버는 그 이상 먼저 메시지를 전송할 수 없습니다. 이 경우 프록시 서버는 Via 헤더에 자기 서버의 정보를 추가하고 나서 리퀘스트에 대해서 리스폰스합니다.

### Warning

Warning 헤더는 HTTP/1.0 리스폰스 헤더(Retry-After)가 HTTP/1.1에서 변경된 것으로, 리스폰스에 관한 추가 정보를 전달합니다. 기본적으로 캐시에 관한 문제의 경고를 유저에 전달합니다.

```
Warning: 113 gw.hackr.jp:8080 "Heuristic expiration"Tue. 03 Jul => 2012 05:09:44 GMT
```

Warning 헤더 형식은 다음과 같이 되어 있습니다. 마지막 날짜는 생략할 수 있습니다.

```
Warning: [경고 코드][경고한 호스트:포트 번호][경고문]" ([날짜])
```

HTTP/1.1에는 7개의 경고 코드가 정의되어 있습니다. 여기에 정의되어 있는 코드에 대한 경고문은 어디까지나 권장 사항입니다. 또한, 경고 코드는 확장성을 가지고 있기 때문에 이후에 코드를 추가할 수 있습니다.

![스크린샷 2023-09-08 오후 7.21.55](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-08 오후 7.21.55.png)

![스크린샷 2023-09-08 오후 7.22.07](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-08 오후 7.22.07.png)

### 리퀘스트 헤더 필드

리퀘스트 헤더 필드는 클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로, 리퀘스트의 부가 정보와 클라이언트의 정보, 리스폰스의 콘텐츠에 관한 우선 순위 등을 추가합니다.

**Accept**

![스크린샷 2023-09-08 오후 7.26.24](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-08 오후 7.26.24.png)

Accept 헤더 필드는 유저 에이전트에 처리할 수 있는 미디어 타입과 미디어 타입의 상대적인 우선 순위를 전달하기 위해서 사용됩니다. 미디어 타입의 지정은 "타입/서브 타입" 으로서 한번에 여러 번 설정할 수도 있습니다. 미디어 타입은 다음과 같은 것들이 있습니다.

- 텍스트 파일

  text/html, text/plain, text/css...

  application/xhtml+xml, application/xml ...

- 이미지 파일

  image/jpeg, image/gif, image/png...

- 동영상 파일

  video/mpeg, video/quicktime...

- 애플리케이션용 바이너리 파일

  application/octet-stream, application/zip...

예를 들면, 브라우저가 PNG 이미지를 표시하지 못하는 경우에는 Accept에 image/png를 지정하지 않고 처리 가능한 image/gif image/jpeg 등을 지 정하도록 합니다. 표시하는 미디어 타입에 우선 순위를 붙이고 싶을 경우에는 세미콜론":"으 로 구분하고 "q="로 표시할 품질 지수를 더합니다. 품질 계수는 0~1의 범위의 수치를(소수점 3자리까지)로 1이 높은 쪽입니다. 품질 계수의 지정이 없는 경우 에는 암묵적으로 "q=1.0"을 나타냅니다. 서버가 복수의 콘텐츠를 반환할 수 있는 경우에는 가장 높은 품질 계수의 미 디어 타입으로 반환할 필요가 있습니다.

**Accept-Charset**

```
Accept-Charset:iso-8859-5, unicode-1-1:q+0.8
```

Accept-Charset 헤더 필드는 유저 에이전트에서 처리할 수 있는 문자셋으로, 문자셋의 상대적인 우선 순위를 전달하기 위해서 사용됩니다. 또한, 문자셋은 한번에 여러 개를 지정할 수 있습니다. Accept 헤더 필드와 마찬가지로, 품질 지수에 의해 상대적 우선 순위를 표시합니다. 이 헤더 필드는 서버 구동형 네고시에이션에 이용됩니다.

**Accept-Encoding**

```
Accept-Encoding: gzip, deflate
```

Accept-Encoding 헤더 필드는 유저 에이전트가 처리할 수 있는 콘텐츠 코딩과 콘텐츠 코딩의 상대적인 우선 순위를 전달하기 위해서 사용됩니다. 콘텐츠 코딩의 지정은 한번에 여러개를 지정할 수 있습니다. 콘텐츠 코딩은 다음과 같은 것들이 있습니다.

- gzip

  파일 압축 프로그램 gzip(GNU zip)에서 생성된 인코딩 포맷(RFC1952)으로 Lempel-Zip 부호(LZ77)와 32비트 CRC를 사용합니다.

- compress

  UNIX 파일 압축 프로그램 "compress"에 의해서 만들어진 인코딩 포맷으로 Lempel-Ziv-Welch 부호(LZW)를 사용합니다.

- deflate

  Zlib 포맷(RFC1950)과 deflate 압축 알고리즘(RFC1951)에 의해서 만들어진 인코딩 포맷을 조합한 것입니다.

- identity

  압축과 변형을 하지 않는 디폴트 인코딩 포맷입니다.

Accept 헤더 필드와 같이 품질지수에 의해서 상대적인 우선 순위를 표시합니다. 또한, "*"(애스터리스크)를 지정하면 와일드 카드로서 모든 인코딩 포맷을 가리킵니다.

**Accept-Language**

```
Accept-Language: ko-kr, en-usiq=0.7.en;q=0.3
```

Accept-Language 헤더 필드는 유저 에이전트가 처리할 수 있는 자연어의 세트(한국어와 영어라는 의미)와 자연어 세트의 상대적인 우선 순위를 전달하기 위해서 사용됩니다. 자연어 세트는 한번에 여러개를 지정할 수 있습니다. Accept 헤더 필드와 같이 품질 지수에 의해 상대적인 우선 순위를 나타냅니다. 위 예의 경우에는 한국어 리소스가 있는 경우에는 한국어로, 없으면 영어 리소스로 리스폰스를 받고 싶다는 것을 나타내고 있습니다.

**Authorization**

```
Authorization: Basic dWVub3NlbjpwYXNzd29yZA==
```

Authorization 헤더 필드는 유저 에이전트의 인증 정보(크리덴셜 값)을 전달하기 위해서 사용됩니다. 통상, 서버에 인증을 받으려 하는 유저 에이전트는 상태코드 401 리스폰스의 뒤에 리퀘스트에 Authorization 헤더 필드를 포함합니다. 공유 캐시가 Authorization 헤더 필드를 포함하는 리퀘스트를 받은 경우에는 조금은 다른 동작을 합니다. HTTP 액세스 인증과 Authorization 헤더 필드에 대해서는 다음 장에서 상세하게 설명합니다. 또는 RFC2616을 참조해 주세요.

**Expect**

```
Expect: 100-continue
```

Expect 헤더 필드는 클라이언트가 서버에 특정 동작 요구를 전달합니다. 기대하고 있는 요구에 서버가 응답하지 못해서 에러가 발생하는 경우에는 상태코드 417 Expectation Failed를 반환합니다. 클라이언트는 이 헤더 필드에 원하는 확장을 딸려 보낼수 있지만 HTTP/1.1의 사양에서는 "100-contitnue"(상태코드 100 Continue의 의미)만 정의되어 있습니다. 상태코드 100 리스폰스를 가진 클라이언트는 리퀘스트할 때에 Expect: 100-continue로 지정해야 합니다.

**From**

From 헤더 필드는 유저 에이전트를 사용하고 있는 유저의 메일 주소를 전달합니다. 기본적으로는 검색 엔진 등의 에이전트 책임자에게 연락처 메일 주소를 나타내는 목적으로 사용됩니다. 에이전트를 사용하는 경우에는 되도록 From 헤더 필드를 포함해야 합니다(에이전트에 따라서는 User-Agent 헤더 필드에 메일 주소를 포함하고 있는 것도 있습니다.)

**Host**

```
Host: www.hackr.jp
```

Host 헤더 필드는 리퀘스트한 리소스의 인터넷 호스트와 포트 번호를 전달합니다. Host 헤더 필드는 HTTP/1.1에서 유일한 필수 헤더 필드입니다. Host 헤더 필드가 존재하는 이유는 1대의 서버에서 복수의 도메인을 할당할 수 있는 가상 호스트의 구조와 매우 깊은 관련이 있습니다. 리퀘스트가 서버에 오면 호스트 명을 IP 주소로 해결해 리퀘스트가 처리됩니다. 이 때 같은 IP 주소로 복수의 도메인이 적용되어 있다고 한다면 어느 도메인에 대한 리퀘스트인지 알 수가 없습니다. 그래서 Host 헤더 필드에 리퀘스트를 받을 호스트명을 명확하게 해둘 필요가 있습니다.

**If-Match**

"If-xxx" 라는 서식의 리퀘스트 헤더 필드는 조건부 리퀘스트라고 부릅니다. 조건부 리퀘스트를 받은 서버는 지정된 조건에 맞는 경우에만 리퀘스트를 받습니다.

```
If-Match: 123456"
```

If-Match 헤더 필드는 조건부 리퀘스트의 하나로 서버 상의 리소스를 특정 하기 위해서 엔티티 태그(ETag)  값을 전달합니다. 이 때 서버는 약한 ETag 값을 사용할 수 없습니다(ETag 헤더 필드의 조항을 참조). 서버는 If-Match의 필드 값과 리소스의 ETag 값이 일치한 경우에만 리퀘스트를 받아들일 수 있습니다. 일치하지 않으면 상태 코드 412 Precondition Failed 리스폰스를 반환합니다. If-Match 필드 값에"*"를 지정할 수도 있습니다. 이 경우에는 ETag 값에 구애받지 않고 리소스가 존재하면 리퀘스트를 처리할 수 있습니다.

**If-Modified-Since**

```
If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT
```

If-Modified-Since 헤더 필드는 조건부 리퀘스트의 하나로 리소스가 갱신 날짜가 필드 값보다 새롭지 않다면 리퀘스트를 받아들이겠다는 뜻을 전달합니다. 필드 값에 지정된 날짜 이후에, 지정한 리소스가 갱신되어 있지 않은 경우에는 상태 코드 304 Not Midofied 리스폰스를 반환합니다.

**If-None-Match**

If-None-Match 헤더 필드는 조건부 리퀘스트의 하나로 If-Match 헤더 필드와는 반대로 동작을 합니다. If-None-Match의 필드 값에 지정된 엔티티 태그(ETag) 값이 지정된 리소스의 ETag 값과 일치하지 않으면 리퀘스트를 받아들이겠다는 뜻을 전달합니다. GET과 HEAD 메소드에서 If-None-Match 헤더 필드를 사용함으로써 최신의 리소스를 요구하는 것이 되기 때문에 If-Modified-Since 헤더 필드를 사용하는 것과 비슷합니다.

**If-Range**

If-Range 헤더 필드는 조건부 리퀘스트의 하나로 If-Range로 지정한 필드값(ETag 값, 혹은 날짜를 지정)과 지정한 리소스의 ETag 값 혹은 날짜가 일치하면 Range 리퀘스트로서 처리하고 싶다는 것을 전달합니다. 일치하지 않는 경우에는 리소스 전체를 반환합니다. If-Range 헤더 필드를 사용하지 않는 리퀘스트를 생각해 봅시다. 서버 측의 리소스가 갱신되어 있는 경우, 클라이언트 측에서 가지고 있는 리소스의 일부분은 무효한 것이 되기 때문에 Range 리퀘스트는 당연히 무효합니다. 이 경우에 서버는 일단 상태 코드 412 Precondition Failed 리스폰스를 반환하고 클라이언트에 다시 리퀘스트를 보내도록 재촉합니다. If-Range 헤더 필드를 이용하는 경우와 비교하면 2배의 수고가 필요하게 됩니다.

**If-Unmodified-Since**

```\
If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT
```

If-Unmodified-Since 헤더 필드는 If-Modified-Since 헤더 필드와 반대로 동작을 합니다. 지정된 리소스가 필드 값에 지정된 날짜 이후에 갱신되어 있지 않은 경우에만 리퀘스트를 받아들이도록 전달합니다. 지정된 날짜 이후에 갱신된 경우에는 상태코드 412 Precondition Failed 리스폰스를 반환합니다.

**Max-Forwards**

```
Max-Forwards: 10
```

Max-Forwards 헤더 필드는 TRACE 혹은 OPTIONS 메소드에 의한 리퀘스트를 할 때에 전송해도 좋은 서버 수의 최대치를 10진수 정수로 지정합니다. 서버는 다음 서버에 리퀘스트를 전송할 때는 Max-Forwards 값에서 1을 빼서 다시 세트합니다. Max-Forwards 값이 0인 리퀘스트를 받은 경우에는 전송하지 않고 리스폰스를 반환할 필요가 있습니다. HTTP를 사용한 통신에서는 리퀘스트가 프록시 서버 등 여러대의 서버를 경유해 가는 경우가 있습니다. 도중에 프록시 서버에서 무언가의 원인으로 리퀘스트 전송이 실패하게 되면 클라이언트에는 리스폰스가 되돌아 오지 않기 때문에 알 수가 없습니다. 이러한 문제가 발생한 경우의 원인조사에 Max-Forwards 헤더 필드는 활용됩니다. 필드 값이 0이 되었던 서버가 리스폰스를 하기 때문에 그 서버까지의 상황을 알 수 있습니다.

**Proxy-Authorization**

```
Proxy-Authorization: Basic dGlwOjkpNLAGfFY5
```

Proxy-Authorization 헤더 필드는 프록시 서버에서의 인증 요구를 받아들인 때에 인증에 필요한 클라이언트의 정보를 전달합니다. 클리아이언트와 서버의 HTTP 액세스 인증과 비슷한데 다른 점은 클라이언트와 프록시 사이에 인증이 이루어진다는 것입니다. 클라이언트와 서버의 경우, Authorization 헤더 필드와 같은 역할을 합니다. HTTP 액세스 인증에 대해서는 다음장에서 자세하게 설명합니다.

**Range**

```
Range: bytes=5001-10000
```

Range 헤더 필드는 리소스의 일부분만 취득하는 Range 리퀘스트를 할 때 지정 범위를 전달합니다. 위에 소개한 예에서는 5001 바이트부터 10000 바이트까지 리소스를 요구하고 있습니다. Range 헤더 필드가 달린 리퀘스트를 받아들인 서버가 리퀘스트를 처리할 수 있는 경우에는 상태 코드 206 Partial Content 리스폰스를 반환합니다. Range 리퀘스트를 처리할 수 없는 경우에는 상태 코드 200 OK 리스폰스로 리소스 전체를 반환합니다.

**Referer**

```
Referer: http://www.hackr.jp/index.htm
```

Referer 헤더 필드는 리퀘스트가 발생한 본체 리소스의 URI를 전달합니다. 기본적으로 Referer 헤더 필드는 보내져야 하지만, 브라우저의 주소창에 직접 URI를 입력한 경우와 보안상 바람직하지 않다고 판단된 경우에는 보내지 않아도 괜찮습니다. 본래 리소스의 URI의 쿼리에 ID 및 패스워드와 비밀 정보 등이 포함되어 있는 경우, Referer를 통해서 그 정보가 다른 서버에 누설되어 버릴 가능성이 있습니다. 또한, Referer 철자는 "Referrer"가 올바르지만, 잘못된 철자 그대로 사용되고 있습니다.

**TE**

```
TE: gzip, deflate;q=0.5
```

TE 헤더 필드는 리스폰스로 받을 수 있는 전송 코딩의 형식과 상대적인 우선 순위를 전달합니다. Accept-Encoding 헤더 필드와 매우 비슷하지만 여기선 전송 코딩에 적용됩니다. TE 헤더 필드는 전송 코딩 지정 이외에 Trailer를 동반하는 청크 전송 인코딩 형식을 지정하는 것이 가능합니다. 이 경우, 필드 값에 "trailers"라고 기록합니다.

```
TE: trailers
```

**User-Agent**

```
User-Agent:Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.19 (KHTML. like Gecko) Chrome/18.0.1025.162 Safari/535.195
```

User-Agent 헤더 필드는 리퀘스트를 생성한 브라우저와 유저 에이전트의 이름 등을 전달하기 위한 필드입니다. 로봇 엔진의 리퀘스트의 경우에는 로봇 엔진의 책임자 메일 주소가 부가된 것도 있습니다. 또는 프록시 경유로 리퀘스트의 경우에는 프록시 서버의 이름 등이 부가된 것도 있습니다.

### 리스폰스 헤더 필드

리스폰스 헤더 필드는 서버 측으로부터 클라이언트 측으로 송신되는 리스폰스 메시지에 적용된 헤더로 리스폰스의 부가 정보나 서버의 정보, 클라이언트에 부가 정보 요구 등을 나타냅니다.

**Accept-Ranges**

```
Accept-Ranges: bytes
```

Accept-Ranges 헤더 필드는 서버가 리소스의 일부분만 지정해서 취득할 수 있는 Range 리퀘스트를 접수할 수 있는지 여부를 전달합니다. 지정 가능한 필드 값은 2개이며 수신 가능한 경우에는 "bytes", 수신 불가능한 경우에는 "none"이라고 기록합니다.

**Age**

```
Age: 600
```

Age 헤더 필드는 얼마나 오래 전에 오리진 서버에서 리스폰스가 생성되었는지를 전달합니다. 필드 값의 단위는 초입니다. 리스폰스한 서버가 캐시 서버라면, 캐시된 리스폰스가 다시 실증되었던 때부터 검증한 시간이 됩니다. 프록시가 리스폰스를 생성했다면 Age 헤더 필드는 필수입니다.

**ETag**

```
ETag: 82e22293907ce725faf67773957acd12"
```

ETag 헤더 필드는 엔티티 태그라고 불리며 일의적으로 리소스를 특정하기 위한 문자열을 전달합니다. 서버는 리소스마다 ETag 값을 할당합니다. 또 리소스가 갱신되면 ETag 값도 갱신할 필요가 있습니다. ETag 값의 문자에는 특별히 룰이 정해져 있지 않고 서버에 따라 다양한 ETag 값을 할당합니다. 리소스를 캐시할 대는 리소스를 일의적으로 정하고 싶은 상황이 있습니다. 예를 들면, http://www.google.com/에 한국어 버전의 브라우저를 사용해서 액세스하면 한국어의 리소스가 반환되지만 영문판 브라우저를 사용해서 액세스하면 영어의 리소스를 반환합니다. 둘다  URI는 같지만 URI 만으로는 캐시했었던 리소스를 특정하는 것은 어렵습니다. 도중에 다운로드가 끊겨서 다시 하는 경우에 ETag 값을 참조해서 리소스를 특정합니다.

*강력한 ETag 값과 약한 ETag 값*

ETag에는 강한(strong) ETag 값과 약한(weak) ETag 값으로 구별되어 있습니다.

- 강한 ETag 값

  강한 ETag 값은 엔티티가 아주 조금 다르더라도 반드시 값은 변화합니다.

  ```
  ETag: "Usagi-1234"
  ```

- 약한 ETag 값

  약한 ETag 값은 리소스가 같다는 것만을 나타냅니다. 의미가 다른 리소스로 그 차이가 있는 경우에만 ETag 값이 변화합니다. 또한, 값의 앞부분에 "W/"가 붙습니다.

  ```
  ETag: W/usagi-1234"
  ```

**Location**

```
Location: http://www.usagidesign.jp/sample.html
```

Location 헤더 필드는 리스폰스의 수신자에 대해서 Request-URI 이외의 리소스 액세스를 유도하는 경우에 사용됩니다. 기본적으로, "3xx: Redirection" 리스폰스에 대해서 리다이렉트 처의 URI를 기술합니다. 대부분의 브라우저에서는 Location 헤더 필드를 포함한 리스폰스를 받으면 강제로 리다이렉트 하는 곳의 리소스에 액세스를 시도합니다.

**Proxy-Authenticate**

```
Proxy-Authenticate: Basic realm="Usagidesign Auth"
```

Proxy-Authenticate 헤더 필드는 프록시 서버에서의 인증 요구를 클라이언트에 전달합니다. 클라이언트와 서버와의 HTTP 액세스 인증과 비슷한데 다른 점은 클라이언트와 프록시 사이에서 인증이 이루어진다는 것입니다. 클라이언트와 서버의 경우, WWW-Authorization 헤더 필드와 같은 역할을 합니다. HTTP 액세스 인증에 대해서는 다음 장에서 상세하게 설명합니다.

**Retry-After**

```
Retry-After: 120
```

Retry-After 헤더 필드는 클라이언트가 일정 시간 후에 리퀘스트를 다시 시행해야 하는지를 전달합니다. 주로 상태 코드 503 Service Unavailable 리스폰스나 3xx Redirect 리스폰스와 함께 사용됩니다. 값으로는 날짜(Web, 04 Jul 2012 06:34:24 GMT 등의 형식)이라든가 리스폰스 이후의 몇 초를 지정할 수 있습니다.

**Server**

```
Server: Apache/2.2.17(Unix)
```

Server 헤더 필드는 서버에 설치되어 있는 HTTP 서버의 소프트웨어를 전달합니다. 단순히 서버의 소프트웨어 명칭만이 아닌, 버전이나 옵션에 대해서도 기재하는 경우가 있습니다.

```
Sever: Apache/2.2.6 (Unix) PHP/5.2.5
```

**Vary**

```
Vary: Accept-Language
```

Vary 헤더 필드는 캐시를 컨트롤하기 위해서 사용합니다. 오리진 서버가  프록시 서버에 로컬 캐시를 사용하는 방법에 대한 지시를 전달합니다. 오리진 서버로부터 Vary에 지정되었던 리스폰스를 받아들인 프록시 서버는 이후 캐시된 때의 리퀘스트와 같은 Vary에 지정되어 있는 헤더 필드를 가진 리퀘스트에 대해서만 캐시를 반환할 수 있습니다. 같은 리소스에 대한 리퀘스트라도 Vary에 지정되었던 헤더 필드가 다른 경우에는 오리진 서버로부터 리소스를 취득할 필요가 있습니다.

**WWW-Authenticate**

```
WWW-Authenticate: Basic realm="Usagidesign Auth"
```

WWW-Authenticate 헤더 필드는 HTTP 액세스 인증에 사용되는데  Request-URI에 지정했던 리소스에 적용할 수 있는 인증 스키마("Basic" 혹은 "Digest")와 파라미터를 나타내는 challenge를 전달합니다. HTTP 헤더 필드는 상태코드 401 Unauthorized 리스폰스에 반드시 포함됩니다. 이 예에서 "realm"은 Request-UrI에 지정된 보호되었던 리소스를 식별하기 위한 문자열입니다. 이 헤더에 대해서는 다음 장에서 상세하게 설명합니다.

### 엔티티 헤더 필드

엔티티 헤더 필드는 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠의 갱신 시간 같은 엔티티에 관한 정보를 포함합니다.

**Allow**

```
Allow: GET, HEAD
```

Allow 헤더 필드는 Request-URI에 지정된 리소스가 제공하는 메소드의 일람을 전달합니다. 서버가 받을 수 없는 메소드를 수신한 경우에는 상태 코드 405  Method Not Allowed 리스폰스와 함께 수신 가능한 메소드의 일람을 기술한 Allow 헤더 필드를 반환합니다.

**Content-Encoding**

```
Content-Encoding: gzip
```

Content-Encoding 헤더 필드는 서버가 엔티티 바디에 대해서 실시한 콘텐츠 코딩 형식을 전달합니다. 콘텐츠 코딩은 엔티티의 정보가 누락되지 않도록 압축할 것을 지시합니다. 주로 다음의 4가지 콘텐츠 형식이 사용됩니다(각 형식의 설명은 Accept-Encoding 헤더 필드를 참조).

- Gzip
- Compress
- Deflate
- Identity

**Content-Language**

```
Content-Language: en
```

Content-Language 헤더 필드는 엔티티 바디에 사용된 자연어(한국어나 영어 등)를 전달합니다.

**Content-Length**

```
Content-Length: 15000
```

Content-Length 헤더 필드는 엔티 바디에 대응하는 URI를 전달합니다. Location 헤더 필드와 달리 Content-Length은 메시지 바디로 반환된 리소스의 URI를 나타냅니다. 예를 들면, Accept-Language 헤더 필드를 사용한 서버 구동형 리퀘스트는 실제로 요구된 오브젝트와는 다른 페이지가 반환되었을 때, Content-Length 헤더 필드에 URI를 포함합니다(http://www.hackr.jp/에 액세스해서 되돌아온 오브젝트가 http://www.hackr.jp/index-ja.html인 경우 등입니다).

**Content-MD5**

```
Content-MD5: OGFKZDUWNGVhNGY3N2MXMDIwZmQ4NTBmY2lyTY==
```

Content-MD5 헤더 필드는 메시지 바디가 변경되지 않고 도착했는지 확인하기 위해 MD5 알고리즘에 의해서 생성된 값을 전달합니다. 메시지 바디에  MD5 알고리즘을 적용해서 얻은 128비트의 바이너리 값에 Base64 인코딩을 한 결과를 필드 값에 기록합니다.  HTTP 헤더에는 바이너리 값을 기록하는 것이 불가능하기 때문에  Base64로 인코딩하고 있습니다. 유효성을 확인하기 위해서는 수신한 클라이언트 측에서 메시지 바디에 같은 MD5 알고리즘을 실행합니다. 이렇게 해서 도출한 값과 필드 값을 비교하여 메시지 바디가 올바른지 여부를 알 수가 있습니다.

**Content-Range**

```
Content-Range: bytes 5001-10000/10000
```

Content-Range 헤더 필드는 엔티티 바디에 포함되는 오브젝트의 미디어 타입을 전달합니다. Accept 헤더 필드와 같이, 필드 값은 "타입/서브 타입"으로 기록합니다. Charset 파라미터는 "iso-8859-1"과 "euc-kr"등의 문자셋을 지정합니다.

**Expires**

```
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```

Expires 헤더 필드는 리소스의 유효 기한 날짜를 전달합니다. 캐시 서버가 Expires 헤더 필드를 포함한 리소스를 수신한 경우 필드 값으로 지정된 날짜까지 리스폰스의 복사본을 유지하고 리퀘스트에는 캐시로 응답합니다. 지정 날짜까지 리스폰스의 복사본을 유지하고 리퀘스트에는 캐시로 응답합니다. 지정 날짜가 지난 경우에는 리퀘스트가 온 단계에서 오리진 서버에 리소스를 얻으러 갑니다. 오리진 서버가 캐시 서버에 캐시되는 것을 원하지 않을 경우에는 Date 헤더 필드의 필드 값과 같은 날짜로 해두는 것이 바람직합니다. 다만 Cache-Control 헤더 필드에 max-age 디렉티브가 지정되어 있는 경우에는 Expires 헤더 필드보다  max-age 디렉티브의 지정이 우선됩니다.

**Last-Modified**

```
Last-Modified: Wed. 23 May 2012 09:59:55 GMT
```

Last-Modified 헤더 필드는 리소스가 마지막으로 갱신되었던 날짜 정보를 전달합니다. 기본적으로는 Request-URI가 지정된 리소스가 갱신되었던 날짜가 되지만, CGI 등의 스크립트로 동적인 데이터를 다룰 경우에는 그 데이터의 최종 갱신 날짜가 되는 경우도 있습니다.

### 쿠키를 위한 헤더 필드

서버와 클라이언트 간의 상태를 관리하는 쿠키는 HTTP/1.1의 사양인 RFC2616에 포함된 것은 아니지만 웹 사이트에서 널리 사용되고 있습니다. 쿠키는 유저 식별과 상태 관리에 사용되고 있는 기능입니다. 웹 사이트가 유저의 상태를 관리하기 위해서 웹 브라우저 경유로 유저의 컴퓨터 상에 일시적으로 데이터를 기록해 두고, 다음에 그 유저가 웹 사이트에 액세스 해 왔을 때 지난번에 발행한 쿠키를 송신받을 수 있습니다. 쿠키가 호출되었을 때는 쿠키의 유효 기한과 송신지의 도메인, 경로, 프로토콜 등을 체크하는 것이 가능하기 때문에, 적절하게 발행된 쿠키는 다른 웹 사이트와 공격자의 공격에 의해 데이터가 도난당하는 일은 없습니다.

쿠키의 사양서는 2013년 5월 기준으로 아래와 같이 4종류가 있습니다.

1. 넷스케이프사에 의한 사양

   쿠키를 고안한 넷스케이프 커뮤니케이션스 사의 사양으로 1994년 경에 넷스케이프 브라우저에 기능이 추가되었습니다. 현재 널리 보급되어 있는 쿠키 방식의 근원이 되어 있습니다.

2. RFC2109

   한 기업의 독자적인 기술이었던 쿠키 사양의 표준화를 시험해 보기 위해서 정리된 규격입니다. 넷스케이프 사에 의한 사양과 상호 운영을 꾀하고 있었지만 미묘하게 다릅니다. 현재는 사용되지 않습니다.

3. RFC2965

   인터넷 익스플로러와 넷스케이프 내비게이터의 서로 다른 규격 때문에 일어난 브라우저 전쟁에 종지부를 찍기 위해서 새롭게 "Set-Cookie2"와 "Cookie2" 라는 HTTP 헤더 필드를 정의했지만 실제로는 거의 사용되지 않습니다.

4. RFC6265

   넷스케이프사에 의한 사양을 디 펙토 스탠다드로서 쿠키의 사양을 재정의한 것입니다. 현재 가장 잘 사용되고 있는 쿠키 사양은 RFC에서 정의되어 있는 그 어떤 것도 아닙니다. 넷스케이프사의 사양을 근간으로 확장한 것입니다. 여기서는 가장 넓게 보급되어 있는 사양을 설명하고 있습니다. 쿠키에 관련된 헤더 필드는 다음과 같은 것이 사용되고 있습니다.

   

   ![스크린샷 2023-09-14 오전 12.47.17](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-14 오전 12.47.17.png)

**Set-Cookie**

```
Set-Cookie: status-enable; expires=Tue. 05 Jul 2011 07:26:31 GMT; =>path=/;domain=hack.jp
```

서버가 클라이언트에 대해서 상태 관리를 시작할 때 다양한 정보를 전달합니다. 필드 값에는 다음과 같은 정보가 기술됩니다.

![스크린샷 2023-09-14 오전 2.19.42](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-14 오전 2.19.42.png)

1. Expires 속성

   쿠키의 Expires 속성은 브라우저가 쿠키를 송출할 수 있는 유효 기한을 지정할 수 있습니다. Expires 속성을 생략한 경우에는 브라우저 세션이 유지되고 있는 동안만 유효하게 됩니다. 이것은 통상은 브라우저 애플리케이션을 닫을 때까지 입니다. 또한, 한번 서버에 송출한 클라이언트의 쿠키는 서버에서 명시적으로 삭제하는 방법은 없습니다. 유효 기한이 지났다면 쿠키를 덮어 쓰는 것으로 실질적인 클라이언트 측의 쿠키를 삭제하는 것이 가능합니다.

2. Path 속성

   쿠키의 Path 속성은 쿠키를 송출하는 범위를 특정 디렉토리에 한정할 수 있습니다. 그러나 이 지정을 피하는 방법이 있어서 보안 효과는 기대할 수 없습니다.

3. Domain 속성

   쿠키의 domain 속성에 의해서 지정된 도메인 명은 후방 일치가 됩니다. 예를 들면, "example.com"로 지정했을 때 "example.com" 이외에 "www.example.com"과 "www2.example.com"등에서도 쿠키가 송출됩니다. 그렇기 때문에 명시적으로 여러 도메인에 대해서 쿠키를 송출하는 경우를 제외하고  domain 속성은 지정하지 않는 쪽이 안전합니다.

4. Secure 속성

   쿠키의  secure 속성은 웹 페이지가 HTTPS에서 열렸을 때에만 쿠키 송출을 제한하기 위해서 지정합니다. 아래와 같이 쿠키를 발행할 때에 secure 속성을 지정해서 실시합니다.

   ```
   Set-Cookie: name=value: secure
   ```

   위의 경우, [https://www.example.com/](HTTPS)일때만 쿠키 반송을 합니 다. 즉, 도메인이 같더라도 [http://www.example.com](HTTP)에는 쿠키 반송 을 하지 않습니다. Secure 속성을 생략한 경우에는 HTTP와  HTTPS에서도 쿠키를 반송합니다.

5. HttpOnly 속성

   쿠키의 HttpOnly 속성은 자바스크립트를 경유해서 쿠키를 취득하지 못하도록 하는 쿠키의 확장 기능입니다. 크로스 사이트 스크립팅(XSS)으로부터 쿠키의 도청을 막는 것을 목적으로 하고 있습니다.

   아래와 같이 쿠키를 발행할 때에 HttpOnly 속성을 지정하면 됩니다.

   ```
   Set-Cookie: name=value; HttpOnly
   ```

   위의 경우, 통상 웹페이지 내에서는 쿠키를 읽어 들이는 것은 가능하지만 HttpOnly 속성이 부여된 쿠키는 Javascript의 [document.cookie]에서는 읽어 들일 수 없게 됩니다. 그렇기 때문에 XSS에서 Javascript를 이용해 쿠키를 훔칠 수 없습니다. 독자적으로 확장한 기능이지만 인터넷 익스플로러 6 SP1 이상의 브라우저를 비롯한 현재 주요한 브라우저에서는 거의 모두 대응하고 있습니다. 또한  XSS 자체를 막는 것은 아닙니다.

**Cookie**

```
Cookie: status=enable
```

Cookie 헤더 필드는 클라이언트가 HTTP의 상태 관리 지원을 원할 때 서버로부터 수신한 쿠키를 이후의 리퀘스트에 포함해서 전달합니다. 쿠키를 여러 개 수신하고 있을 때에는 쿠키를 여러 개 보내는 것도 가능합니다.

### 그 이외의 헤더 필드

HTTP 헤더 필드는 독자적으로 확장할 수 있습니다. 그렇기 때문에 웹 서버와 브라우저의 기능에 다양한 독자적인 헤더 필드가 존재합니다. 그 중에서도 자주 사용되는 아래의 헤더 필드에 대해서 설명합니다

- X-Frame-Option
- X-XSS-Protection
- DNT
- P3P

**X-Frame-Option**

```
X-Frame-Option: DENY
```

X-Frame-Option 헤더 필드는 다른 웹 사이트의 프레임에서 표시를 제어하는 HTTP 리스폰스 헤더로, 클릭 재킹(click jacking)이라는 공격을 막는 것을 목적으로 하고 있습니다. X-Frame-Option 헤더필드에 지정할 수 있는 값은 아래와 같습니다.

- DENY : 거부
- SAMEORIGIN : 
- Top-level-browsing-context가 일치한 경우에만 허가(예를 들면, http://hackr.jp/sample.html이 SAMEORIGIN을 지정하 고 있던 경우 hackr.jp 상의 페이지를 프레임에 읽어 들이는 것은 가능하 지만 example.com과 같은 다른 도메인의 페이지에서는 불가능합니다)

이 헤더 필드가 유효한 있는 브라우저는 인터넷 익스플로러 8, 파이어폭스 3.69+, 크롬 4,1,249,1042+, 사파리 4+, 오페라 10.50+ 이상이 해당됩니다. X-Frame-Options는 모든 웹 서버에서 설정해두는 것이 바람직합니다.

**X-XSS-Protection**

```
X-XSS-Protection: 1
```

X-XSS-Protection 헤더 필드는 크로스 사이트 스크립팅(XSS) 대첵으로서 브라우의 XSS 보호 기능을 제어하는 HTTP 리스폰스 헤더입니다. X-XSS-Protection 헤더 필드에 지정할 수 있는 값은 아래와 같은 것이 있습니다.

- 0 : XSS 필터를 무효로 한다.
- 1 : XSS 필터를 유효로 한다.

**DNT**

```
P3P: CP="CAO DSP LAW CURA ADMa DEVA TAla PSAa PSDa IVAa IVDa OUR BUS IND UNI COM NAV INT"
```

P3P 헤더 필드는 웹 사이트 상의 프라이버시 정책에 P3P(The Platform for Privacy Preferences)를 사용하는 것으로, 프로그램이 읽을 수 있는 형태로 나 타내기 위한 HTTP 리스폰스 헤더입니다.

P3P 설정을 할 때 다음과 같은 순서로 실행합니다.

- 수순-1 : P3P정책작성

- 수순-2 : P3P 정책 참조 파일을 작성해서 "/w3c/p3p.xml"에 배치

- 수순-3 : P3P 정책으로부터 콤팩트 정책을 작성하고 HTTP 리스폰스 헤

  더에 출력
