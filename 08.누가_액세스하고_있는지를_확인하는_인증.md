## 인증이란?

컴퓨터는 모니터 앞에 앉아 있는 사람이 누구인지 알 수가 없습니다. 게다가 네트워크 저편에 누가 있는지 알 수가 없습니다. 그래서 서버에 액세스하고 있는 사람이 누군지 알려면 상대방 클라이언트에 이름을 알려달라고 해야 합니다. 다만, 액세스 하고 있는 쪽이 "홍길동"이라고 이름을 밝히더라도, 이것이 정말인지 아닌지를 알 수가 없습니다. 시스템에 액세스하는 권한을 가진 "홍길동" 본인인지 아닌지를 확인하기 위해서는 [등록된 본인만이 알고 있는 정보]나 [등록한 본인만이 가지고 있는 정보] 등으로 확인할 필요가 있습니다.

이러한 정보에는 주로 다음과 같은 것이 사용되고 있습니다.

- 패스워드 : 본인만이 알고 있는 문자열 정보
- 원타임 토큰 : 본인만이 가지고 있는 기기 등에 표시되는 한 번 쓰고 버리는 패스워드 등의 정보
- 전자 증명서 : 본인(단말기)만이 가지고 있는 정보
- 바이오 매트릭스 : 지문이나 홍채 등 본인의 신체 정보
- IC 카드 등 : 본인만이 가지고 있는 정보

단, 상대가 가짜라 하더라도 본인 확인을 하기 위한 정보를 제시할 수 있다면 컴퓨터는 본인으로 인식해 버립니다. 그래서 패스워드 등의 정보는 타인에게 알려지지 않게 하고 더욱이 쉽게 추측할 수 없도록 해야 합니다.

**HTTP에서 사용하는 인증 방법**

HTTP/1.1에서 이용할 수 있는 인증 방식에는 다음과 같은 것이 있습니다.

- BASIC 인증
- DIGEST 인증
- SSL 클라이언트 인증
- 폼 베이스 인증

이번 장에서는 설명하지 않지만 이 밖에도 통합 Windows 인증(Kerberos 인증, NTLM 인증) 등이 있습니다.

### BASIC 인증

BASIC 인증은 HTTP/1.0에 구현된 인증 방식으로 현재에도 일부 사용되고 있습니다. BASIC 인증은 웹 서버와 대응하고 있는 클라이언트 사이에서 이뤄지는 인증 방식입니다.

**BASIC 인증 수순**

1. BASIC 인증이 필요한 리소스에 리퀘스트가 있을 경우에는 서버는 상태 코드 401 Authorization Required와 함께 인증의 방식(BASIC)과 Request-URI의 보호 공간을 식별하기 위한 문자열(realm)을 WWW-Authenticate 헤더 필드에 포함해서 리스폰스를 반환합니다.
2. 상태 코드 401을 받은 클라이언트는 BASIC 인증을 위해서 유저 ID와 패스워드를 서버에 송신할 필요가 있습니다. 송신하는 문자열은 유저 ID와 패스워드를 콜론":" 으로 연결한 문장을 Base64이라 불리는 형식으로 인코드한 것입니다. 유저 ID가 "guest"이고 패스워드가 "guest"인 경우 연결하면 "guest:guest"와 같이 문자열이 됩니다. 이것을 Base64 인코드하면 "Z3V1c3Q6Z3Vlc3Q="이 됩니다. 이 문자열을 Authorization 헤더 필드에 포함해서 리퀘스트를 송신합니다. 유저 에이전트에 브라우저를 사용하고 있는 경우에는 이용자가 유저 ID와 패스워드를 입력하면 브라우저가 자동적으로 Base64로 변환됩니다.
3. Authorization 헤더 필드를 포함한 리퀘스트를 수신한 서버는 인증 정보가 정확한지 여부를 판단합니다. 인증 정보가 정확하면 Request-URI 리소스를 포함한 리스폰스를 반환합니다.

BASIC 인증에서는 Base64라는 인코딩 형식을 사용하고 있지만 이것은 암호화는 아니기 때문에 아무런 부가 정보 없이도 복호화 할 수 있습니다. 즉, HTTPS 등에서 암호화되지 않은 통신 경로 상에서 BASIC 인증을 해서 도청된 경우에는 복호화된 유저 ID와 패스워드를 빼앗길 가능성이 있습니다. 또, 그 이외에도 한번 BASIC 인증을 하면, 일반 브라우저에서는 로그아웃할 수 없다는 문제도 있습니다. BASIC 인증은 사용상의 문제와 많은 웹 사이트에서 요구되는 보안 등급에는 미치지 못한다는 면에서 그다지 사용되고 있지는 않습니다.

### DIGEST 인증

BASIC 인증의 약점을 보완하며 HTTP/1.1에 소개되어 있습니다. BASIC 인증에는 챌린지 리스폰스 방식이 사용되고 있어서 BASIC 인증과 같이 패스워드를 있는 그대로 직접 보내는 일은 없습니다. 챌린지 리ㅡㅅ폰스 방식은 최초에 상대방에게 인증 요구를 보내고 상대방측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산합니다. 이 값을 상대에게 송신하여 인증을 하는 방법입니다. 리스폰스 코드라는 패스워드와 챌린지 코드를 이용해서 계산한 결과를 상대에게 보내기 때문에 BASIC 인증과 같은 방식에 비하면 패스워드가 누출될 가능성이 줄어듭니다.

![스크린샷 2023-10-18 오후 4.18.45](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-18 오후 4.18.45.png)

**DIGEST 인증 수순**

1. 인증이 필요한 리소스에 리퀘스트가 있을 경우에는 서버는 상태 코드 401 Authorization Required와 함께 챌린지 리스폰스 방식의 인증에 필요한 챌린지 코드(nonce)를 WWW-Authenticate 헤더 필드에 포함해서 리스폰스를 반환합니다. WWW-Authenticate헤더 필드에 반드시 포함되어야 하는 정보는 "realm"와 "nonce" 두 개입니다. 클라이언트와 이 값을 서버에 보내는 것으로 인증합니다. nonce는 401 리스폰스를 반환할 때마다 생성되는 유일한 문자열입니다. 이 문자열은 Base64이거나 16진수가 권장되고 있습니다. 문자열의 내용에 관해서는 구현된 서버에 의존합니다.
2. 상태 코드 401을 수신한 클라이언트는 DIGEST 인증을 위해 필요한 정보를 Authorization 헤더 필드에 포함해서 리스폰스를 반환합니다. Authorization 헤더 필드에 반드시 포함되어야 하는 정보는 "username", "realm", "nonce", "uri", "response" 입니다. 이 중에서 "realm"하고 "nonce"는 서버에서 받은 것을 사용합니다. username은 지정된 realm에서 인증 가능한 사용자 이름입니다. uri(digest-uri)는 Request-URI에 있는 URI지만 프록시에 의해 Request-URI가 변경되는 경우도 있기 때문에 여기에 복사해 놓습니다. response는 Request-Digest라고 불리는데 패스워드 문자열을 MD5로 계산한 것으로, 이것이 리스폰스 코드입니다. 그 이외에 엔티티에 대해서는 6장에 있는 리스폰스 헤더 필드의 "Authorization"의 항을 참고해 주세요. 또, Request-Digest의 생성 규칙에 대해서는 다소 복잡하기 때문에 RFC2617을 참고해 주세요.
3. Authorization 헤더 필드를 포함한 리퀘스트를 받은 서버는 인증 정보가 정확한 것인지 아닌지를 판단합니다. 인증 정보가 정확한 경우에는 Request-URI의 리소스를 포함한 리스폰스를 반환합니다. 이 때 서버는 Authentication-Info 헤더 필드에 성공한 인증에 대한 몇 가지 정보를 추가할 때도 있습니다. DIGEST 인증은 BASIC 인증에 비해서 높은 보안 등급을 제공하고 있지만, HTTPS의 클라이언트 인증 등과 비교하면 낮습니다. DIGEST 인증에서는 패스워드의 도청을 방지하기 위한 보호 기능은 제공하고 있지만 이외에 위장을 방지하는 기능은 제공하고 있지 않습니다.

DIGEST 인증도 BASIC 인증과 마찬가지로 사용상의 문제와 많은 웹 사이트에서 요구되는 보안 등급에는 미치지 못한다는 점에서 그다지 사용되고 있지는 않습니다.

### SSL 클라이언트 인증

유저 ID와 패스워드를 사용한 인증 방식은 이 두가지 정보가 정확하다면 본인으로서 인증할 수 있습니다. 그러나 이 정보가 도난되었을 때에는 제 3자가 *위장*을 하는 경우가 있습니다. 이를 방지하기 위한 대책 중의 하나로 SSL 클라이언트 인증이 사용되는 일이 있습니다. SSL 클라이언트 인증은 HTTPS의 클라이언트 인증서를 이용한 인증 방식입니다. HTTPS 장에서 설명했던 클라이언트 증명서를 인증할 때에 사용하는 방식으로 사전에 등록된 클라이언트에서의 액세스인지 아닌지를 확인할 수 있습니다.

**SSL 클라이언트 인증의 인증 수순**

SSL 클라이언트 인증을 할 때에는 사전에 클라이언트에 클라이언트 증명서를 배포하고 인스톨 해둘 필요가 있습니다.

1. 인증이 필요한 리소스의 리퀘스트가 있었을 경우에는 서버는 클라이언트에게 클라이언트 증명서를 요구하는 "Certificate Request"라는 메시지를 송신합니다.
2. 유저는 송신하는 클라이언트 증명서를 선택합니다. 그리고 클라이언트는 클라이언트 증명서를 "Client Certificate"라는 메시지를 송신합니다.
3. 서버는 클라이언트 증명서를 검증하여 검증 결과가 정확하다면 클라이언트의 공개키를 취득합니다. 그 이후에 HTTPS에 의한 암호를 개시합니다.

**SSL 클라이언트 인증은 2-factor 인증에서 사용된다**

SSL 클라이언트 인증은 대부분의 경우 단독으로 사용되지는 않고, 이후에 다룰 폼 베이스 인증과 합쳐서 2-factor 인증의 하나로서 이용되고 있습니다. 2-factor 인증이란 예를 들면 패스워드라는 한 개의 요소만이 아닌 이용자가 가진 다른 정보를 병용해서 인증을 하는 방법입니다. 즉, 첫 번째 인증 정보로서 SSL 클라이언트 인증을 사용하여 클라이언트의 컴퓨터를 인증하고 다른 인증 정보로서 패스워드를 사용하여 유저의 본인 확인을 합니다. 이로 인해 본인이 올바른 컴퓨터에서 액세스하고 있음을 확인할 수 있습니다.

**SSL 클라이언트 인증은 이용하는데 비용이 필요하다**

SSL 클라이언트 인증에서는 클라이언트 증명서를 이용할 필요가 있습니다. 이 클라이언트 증명서를 이용하기 위해서는 비용이 필요하게 됩니다. 이 경우에 비용은 인증 기관에서 클라이언트 증명서를 구입하는 비용이나 서버의 운영자 자신이 인증 기관을 만들어서 안전하게 운용하기 위해 들어가는 비용입니다. 클라이언트 증명서의 비용은 인증 기관에 의해서 다르지만 증명서 한 개당 연간 수만 원에서 수백만 원 정도입니다. 서버 운영자 스스로 인증 기관을 만드는것도 가능하지만 안전하게 운용하기 위해서는 상당한 비용이 발생합니다.

### 폼 베이스 인증

폼 베이스 인증은 HTTP 프로토콜로서 사양이 정의되어 있는 인증 방식은 아닙니다. 클라이언트가 서버 상의 웹 애플리케이션에 자격 정보(Credential)를 송신하여 그 자격 정보의 검증 결과에 따라 인증을 하는 방식입니다. 이것은 웹 애플리케이션에 따라 제공되는 인터페이스나 인증의 방법이 다양합니다. 대부분의 경우에는 사전에 등록해 둔 자격 정보인 유저 ID(임의의 문자열이나 메일주소 등이 자주 사용된다)와 패스워드를 입력해서 이것을 웹 애플리케이션측에 송신하고 검증 결과를 토대로 검증 성공 여부를 결정합니다.

**인증의 대부분은 폼 베이스 인증**

HTTP가 표준으로 제공하는 BASIC 인증이나 DIGEST 인증은 사용상의 문제와 보안적인 문제로 거의 사용되고 있지 않습니다. 또한 보안 등급이 높은 SSL 클라이언트 인증도 도입 비용이나 운용 비용 등의 문제로 널리 사용되고 있지는 못하고 있습니다. 예를 들면 SSH나 FTP와 같은 프로토콜이 서버와 클라이언트 사이에서 사용하는 인증에는 표준적인 것이 있어서 한편으로 필요한 기능의 레벨을 충족하고 있기 때문에 그대로 이용할 수 있습니다. 그러나 웹 사이트의 인증 기능으로서 요구되는 기능의 레벨을 충족시킨 표준적인 것이 존재하지 않기 때문에 웹 애플리케이션에서 제각각 구현하는 폼 베이스 인증을 채용하는 수 밖에 없습니다. 공통 사양이 결정되어 있지 않은 폼 베이스 인증에서는 웹 사이트 별로 다르게 구현을 하고 있습니다. 안전한 방법으로 구현하면 높은 보안 등급을 유지할 수 있지만, 문제 있는 구조를 하고 있는 웹 사이트도 종종 발견할 수 있습니다. 

**세션 관리와 쿠키에 의한 구현**

폼 베이스 인증은 표준적인 사양이 결정되어 있지 않지만 일반적으로 자주 사용되고 있는 방법으로는 세션 관리를 위해서 쿠키를 사용하는 방법이 있습니다. 폼 베이스 인증의 인증 자체는 서버 측의 웹 애플리케이션 등에 의해서 클라이언트가 송신해온 유저 ID와 패스워드가 사전에 등록하고 있는 것과 일치하는지 어떤지를 검증하면서 이루어집니다. 그러나 HTTP는 stateless 프로토콜이기 때문에 방금 전에 인증을 성공했던 유저라는 상태를 프로토콜 레벨에서는 유지할 수 없습니다. 즉, 상태 관리가 안되기 때문에, 다음에 그 유저가 액세스했다고 하더라도 다른 유저와 구별하지 못합니다. 그래서 세션 관리와 쿠키를 사용하여 HTTP에 없는 상태 관리 기능을 보충합니다.

![스크린샷 2023-10-18 오후 5.11.45](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-18 오후 5.11.45.png)

1. 클라이언트와 서버에 유저 ID나 패스워드 등의 자격 정보를 포함한 리퀘스트를 송신합니다. 보통은 POST 메소드가 사용되어 엔티티 바디에 자격 정보를 저장합니다. 이떄, HTML 폼 화면 표시와 입력 데이터의 송신에는 HTTPS 통신을 이용합니다.
2. 서버 측은 유저를 식별하기 위해선 세션 ID를 발행합니다. 클라이언트에서 수신한 자격 정보를 검증하는 것으로 인증을 하고, 그 유저의 인증 상태를 세션 ID와 연관지어 서버 측에 기록합니다. 클라이언트 측에 송신할 때는 Set-Cookie 헤더 필드에 세션 ID(예로는 “PHPSESSID=0288c")를 저장해서 리스폰스를 반환합니다. 세션 ID는 이른바 정리권 번호로 다른 유저와 구별하기 위한 것입니다. 이 세션 ID가 제 3자에게 악용되면 세션 ID의 주인 행세를 할 수 있기 때문에, 도난당하거나 쉽게 유추되지 않도록 해야 할 필요가 있습니다. 그렇기 때문에 세션 ID는 추측하기 어려운 문자열을 사용하고 서버 측에서는 유효 기한을 관리하는 등 보안을 유지할 필요가 있습니다. 또한, 크로스 사이트 스크립팅 등의 취약성이 존재한 경우라도 피래를 줄이기 위해서 쿠키에는 httponly 속성을 부여해 둡시다.
3. 서버 측에서 세션 ID를 받은 클라이언트는 쿠키로 저장해 둡니다. 다음번에 서버에 리퀘스트를 송신하는 때에는 브라우저가 자동으로 쿠키를 송출하기 때문에 세션 ID가 서버에 송신됩니다.

여기에서 소개한 구현 방법은 어디까지나 하나의 예이기 때문에 다른 방법으로 구현된 것도 있습니다. 또한, 폼 베이스 인증에서는 자격 정보를 교환하는 방법은 표준화되어 있지 않을 뿐만 아니라 패스워드 등의 자격 정보를 서버 측에 어떻게 보존해야 하는지도 표준화되어 있지 않습니다. 일반적으로는 안전한 방법으로서 패스워드를 salt라는 부가 정보를 사용해서 해시라는 알고리즘으로 계산한 값을 저장하지만, 평문의 패스워드를 서버에 그대로 보존하고 있는 것도 자주 눈에 띕니다. 이러한 곳에서는 패스워드가 누설 되어 버릴 위험성이 있습니다.