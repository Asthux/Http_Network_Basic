### HTTP를 기본으로 하는 프로토콜

HTTP의 규격이 만들어졌을 무렵에는 주로 HTML로 작성된 문서를 전송하기 위한 프로토콜로 HTTP를 생각했었습니다. 그리고 시대를 거치면서 웹의 용도는 크게 변화하고 있습니다. 쇼핑 사이트나 SNS, 기업이나 조직 내의 각종 관리 툴 등 그 용도는 다방면에 이릅니다. 그것들이 추구하는 기능은 웹 애플리케이션이나 스크립트 등을 구사해서 만들 수 있지만, 기능이 충분하다고 하더라도 결코 효율적이라고는 할 수는 없습니다. HTTP라는 프로토콜의 제한이나 한계가 있기 때문입니다. HTTP의 기능이 부족한다고 한다면 그것을 보완하는 전혀 새로운 프로토콜을 만들 수도 있지만, 이미 웹 브라우저라는 환경이 널리 퍼진 지금 HTTP라는 프로토콜을 무시할 수 없습니다. 그래서 HTTP를 기반으로 해서 여기에 추가하는 형태로 새로운 프로토콜이 몇 가지가 구현되었습니다.

### HTTP의 병목 현상을 해소하는 SPDY

Google이 2010년에 발표한 SPDY[스피디(SPeeDY)]는 HTTP의 병목 현상을 해소하고 웹 페이지 로딩 시간을 50% 단축한다는 목표를 세우고 개발되고 있습니다.

**HTTP의 병목 현상**

페이스북이나 트위터 등의 SNS는 수백만 명, 수천만 명의 유저가 메시지등의 정보를 작성하면 웹 사이트에 그 정보들이 추가되면서 단시간에 대량의 갱신 정보가 발생합니다. 이렇게 갱신된 정보를 가능한 빨리 실시간으로 표시하기 위해서는 서버상의 정보가 갱신되었을 때, 그것을 클라이언트의 화면에 반영할 필요가 있습니다. 단순한 것처럼 생각할 수 있지만 HTTP에서는 이 처리를 제대로 할 수가 없습니다. HTTP에서는 서버의 정보가 갱신되었는지 아닌지를 알기 위해서 클라이언트가 항상 서버 측에 확인하러 가야 합니다. 만약, 서버 상의 정보가 갱신되지 않은 경우에는 불필요한 통신이 발생하게 됩니다. 현재 웹에 요구되고 있는 사용하는 방법으로 하려면 다음과 같은 HTTP의 사양이 병목 현상이 됩니다. 

- 1개의 커넥션으로 1개의 리퀘스트만 보낼 수 있다.
- 리퀘스트는 클라이언트에서만 시작할 수 있다. 리스폰스만 받는 것은 불가능하다.
- 리퀘스트/리스폰스 헤더를 압축하지 않은 체로 보낸다. 헤더의 정보가 많을수록 지연이 심해진다.
- 장황한 헤더를 보낸다. 매번 같은 헤더를 보내는 것은 낭비다.
- 데이터 압축을 임의로 선택할 수 있다. 압축해서 보내는 것이 강제적이지는 않다.

**Ajax에 의한 해결 방법**

Ajax(Asynchronous JavaScript+XML)은 JavaScript나 DOM(Document Object Model) 조작 등을 활용하는 방식으로, 웹 페이지의 일부분만 고쳐쓸 수 있는 비동기 통신 방법입니다. 기존의 동기식 통신에 비해서 페이지의 일부분만 갱신되기 때문에 리스폰스로 전송되는 데이터 양은 줄어든다는 장점이 있습니다. Ajax의 핵심 기술은 XMLHttpRequest라는 API로 JavaScript 등의 스크립트 언어로 서버와 HTTP 통신을 할 수 있습니다. 이것을 사용함으로써 이미 읽어 들인 웹 페이지부터 리퀘스트를 발행할 수 있기 때문에 페이지의 일부 데이터만 받는 것이 가능하게 됩니다. Ajax를 사용해서 실시간으로 서버에서 정보를 취득하려고 하면 대량의 리퀘스트가 발생한다는 문제가 있습니다. 또 HTTP의 프로토콜 자신이 가지고 있는 문제가 해결되는 것은 아닙니다.

**Comet에 의한 해결 방법**

Comet은 서버 측의 콘텐츠에 갱신이 있었을 경우, 클라이언트부터 리퀘스트를 기다리지 않고 클라이언트에 보내기 위한 방법입니다. 응답을 연장시킴으로써, 서버에서 통신을 개시하는 서버 푸시 기능을 유사하게 따르고 있습니다. 통상 리퀘스트가 오면 리스폰스를 바로 반환하지만 Comet에서는 리스폰스를 보류 상태로 해 두고, 서버의 콘텐츠가 갱신되었을 때에 리스폰스를 반환한다는 것입니다. 이것에 의해서 서버에서 갱신된 콘텐츠가 있으면 바로 클라이언트에 반영할 수 있습니다. 콘텐츠를 실시간으로 갱신할 수는 있지만 리스폰스를 보류하기 위해서 커넥션을 유지하는 시간이 길어집니다. 커넥션을 유지하는 동안은 리소스를 소비합니다. 또한 HTTP 자체의 문제가 해결되는 것은 아닙니다.

**SPDY의 목표**

Ajax와 Comet 등 사용성을 쾌적하게 하는 여러 가지 기술이 등장해서 어느정도 개선되었지만, HTTP라는 프로토콜의 제약은 없앨 수는 없습니다. 근본적인 개선을 위해서는 프로토콜 레벨에서의 개선이 필요하게 됩니다. SPDY는 HTTP가 안고 있던 병목 현상을 프로토콜 레벨에서 해소하기 위해 개발이 진행되고 있는 프로토콜입니다.

**SPDY 설계와 기능**

SPDY는 HTTP를 완전히 바꿔 놓는 것이 아니라 TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 새로운 세션 계층을 추가하는 형태로 동작합니다. 또한 SPDY는 보안을 위해서 표준으로 SSL을 사용하도록 되어 있습니다. SPDY가 세션 계층으로서 그 사이에 들어감으로써 데이터의 흐름을 제어하지만, HTTP의 커넥션은 확립되어 있습니다. 그래서 HTTP의 GET이나 POST 같은 메소드나 쿠키, HTTP 메시지 등을 그대로 사용할 수 있습니다.

![스크린샷 2023-10-19 오후 4.01.25](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-19 오후 4.01.25.png)

SPDY를 사용하면 다음과 같은 기능을 HTTP에 추가할 수 있습니다.

*다중화 스트림*

단일 TCP 접속을 통해서 복수의 HTTP 리퀘스트를 무제한으로 처리할 수 있습니다. 한 번의 TCP 접속으로 리퀘스트를 주고 받는 것이 가능하기 때문에 TCP의 효율이 높아집니다.

*리퀘스트의 우선 순위 부여*

SPDY는 무제한으로 리퀘스트를 병렬 처리할 수 있지만, 각 리퀘스트에 우선 순위를 할당할 수 있습니다. 이것은 복수의 리퀘스트를 보낼 때 대역폭이 좁으면 처리가 늦어지는 현상을 해결하기 위해서입니다.

*HTTP 헤더 압축*

리퀘스트와 리스폰스의 HTTP 헤더를 압축합니다. 이로 인해 보다 적은 패킷수와 송신 바이트 수로 통신을 할 수 있습니다.

*서버 푸시 기능*

서버에서 클라이언트로 데이터를 푸쉬하는 서버 푸시 기능을 지원합니다. 그래서 서버 측은 클라이언트 측에서 리퀘스트를 기다리지 않고 데이터를 보낼 수 있습니다.

*서버 힌트 기능*

서버가 클라이언트에게 리퀘스트 해야 할 리소스를 제안할 수 있습니다. 클라이언트가 자원을 발견하기 전에 리소스의 존재를 알 수 있기 때문에 이미 캐시를 가지고 있는 상태라면 불필요한 리퀘스트를 보내지 않아도 됩니다.

**SPDY는 웹의 병목 현상을 해결하는가?**

SPDY를 사용하고 싶을 경우에는 웹 콘텐츠 측은 특별히 의식할 필요는 없지만, 웹 브라우저와 웹 서버는 SPDY에 대응하고 있을 필요가 있습니다. 몇 개의 브라우저에서는 벌써 대응하고 있으며 웹 서버에서도 실험적으로 구현은 되어 있지만 실제로 웹 사이트에 도입은 그다지 진행되어 있지 않습니다. SPDY는 기본적으로 한 개의 도메인(IP 주소)과의 통신을 다중화할 뿐이기 때문에 하나의 웹 사이트에서 복수의 도메인으로 리소스를 사용하고 있는 경우에는 그 효과는 한정적이게 됩니다. SPDY HTTP의 병목 현상을 해결하는 좋은 기술이지만, 대부분 웹 사이트의 문제는 HTTP의 병목 현상 때문만은 아닙니다. 웹 자신을 고속화하기 위해서는 웹 콘텐츠 제작을 개선하는 등 부수적으로 해야 할 일이 많습니다.

### 브라우저에서 양방향 통신을 하는 WebSocket

Ajax와 Comet을 사용한 통신은 웹 브라우징을 고속화 하지만 HTTP라는 프로토콜을 사용하고 있는 이상, 병목 현상을 해결할 수 없습니다. WebSocket은 새로운 프로토콜과 API에 의해 이 문제를 해결하기 위한 기술로서 개발되어 있습니다. 당초는 HTML5의 사양의 일부로서 책정되어 있었지만, 현재는 단독 프로토콜로서 규격 책정이 진행되고 있습니다. 2011년 12월 11일에는 WebSocket의 사 양이 [RFC 6455-The WebSocket Protocol]로 출시되었습니다.

**WebSocket의 설계와 기능**

WebSocket은 웹 브라우저와 웹 서버를 위한 양방향 통신 규격으로 WebSocket 프로토콜을 IETF가 책정하고 WebSocket API를 W3C가 책정하고 있습니다. 주로 Ajax나 Comet에서 사용하는 XMLHttpRequest의 결점을 해결하기 위한 기술로서 개발이 진행되고 있습니다.

**WebSocket 프로토콜**

WebSocket은 웹 서버와 클라이언트가 한번 접속을 확립하면 그 뒤의 통신을 모두 전용 프로토콜로 하는 방식으로 JSON이나 XML, HTML이나 이미지 등 임의 형식의 데이터를 보내게 됩니다. HTTP에 의한 접속의 출발점이 클라이언트에 있다는 것에는 변함이 없지만 한 번 접속을 확립하면 WebSocket을 사용하여 서버와 클라이언트 어느 쪽에서도 송신을 할 수 있게 됩니다. WebSocket 프로토콜의 주요 특징은 다음과 같습니다.

*서버 푸시 기능*

서버에서 클라이언트에 데이터를 푸시하는 서버 푸시 기능을 제공합니다. 그래서 서버는 클라이언트의 리퀘스트를 기다리지 않고 데이터를 보낼 수 있습니다.

*통신량의 삭감*

WebSocket은 접속을 한번 확립하면 접속을 유지하려고 합니다. HTTP에 비해서 자주 접속을 하는 오버헤드가 적어지고, 또 헤더의 사이즈도 작기 때문에 통신량을 줄일 수 있씁니다. WebSocket으로 통신을 하려면 한번 HTTP에 접속을 확립하고, WebSocket에 의해 통신을 하기 위해서 핸드쉐이크 절차를 밟을 필요가 있습니다.

- 핸드쉐이크/리퀘스트

  WebSocket로 통신을 하려면 HTTP의 Upgrade 헤더 필드를 사용해서 프로토콜을 변경하는 것으로 핸드쉐이크를 실시합니다.

  ![스크린샷 2023-10-20 오후 3.45.46](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-20 오후 3.45.46.png)

  Sec-WebSocket-Key에는 핸드쉐이크에 필요한 키가 저장되어 Set-WebSocket-Protocol에는 사용하는 서브 프로토콜이 저장되어 있습니다. 서브 프로토콜은 WebSocket 프로토콜에 의한 커넥션을 여러 개로 구분하고 싶을 때에 이름을 붙여서 정의합니다.

- 핸드쉐이크/리스폰스

  앞선 리퀘스트에 대한 리스폰스는 상태코드 [101 Switching Protocols]로 반환됩니다.![스크린샷 2023-10-20 오후 3.47.19](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-20 오후 3.47.19.png)

  Sec-WebSocket-Accept는 Sec-WebSocket-Key의 값에서 생성된 값이 저장됩니다. 핸드쉐이크에 의해 WebSocket 커넥션이 확립된 후에는 HTTP가 아닌, WebSocket 독자적인 데이터 프레임을 이용해 통신을 합니다.

- JavaScript에서 WebSocket 프로토콜을 사용한 양방향 통신을 하기 위해서는 W3C에서 사양이 책정되어 있는 [The WebSocket API(http://www.w3.org/TR/websockets)]에서 제공되고 있는 WebSocket 인터페이스를 사용합니다. 다음은 WebSocket API를 사용해서 50ms에 1번 데이터를 송신하는 예입니다.![스크린샷 2023-10-20 오후 3.49.42](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-20 오후 3.49.42.png)

### 등장이 기다려지는 HTTP/2.0

현재 주류인 HTTP/1.1은 1999년 공개된 RFC2616 이후로 개정되고 있지 않지만, SPDY나 WebSocket 등의 등장에서 보듯이 이미 HTTP/1.1은 현재의 웹에 적합한 프로토콜이라고는 할 수 없습니다. 인터넷 기술의 표준화를 하고 있는 IETF에서는 httpbis(Hypertext Transfer Protocol Bis)(http:// datatracker.ietf.org/wg/httpbis)라는 워킹 그룹을 만들어 차세대 HTTP가 될 [HTTP/2.0]에 대해서 표준화를 목표로 논의를 진행하고 있습니다.

**HTTP/2.0의 특징**

HTTP/2.0은 사용자가 웹을 이용할 때의 체감 속도의 개선을 목표로 하고 있습니다. HTTP/1.1 경유로 TCP를 사용하는 것이 기본으로 되어 있기 때문에 다음의 프로토콜이 베이스가 되어 사양이 검토되고 있습니다.

- SPDY
- HTTP Speed+Mobility
- Network-Friendly HTTP Upgrade

HTTP Speed+Mobility는 마이크로소프트 사가 제안하고 있는 모바일 통신에서 통신 속도와 효율성을 개선하기 위한 규격입니다. Google 사가 제안하고 있는 SPDY와 WebSocket이 근원이 되고 있습니다. Network-Friendly HTTP Upgrade는 주로 모바일 통신에서 HTTP의 효율 개선을 위한 규격입니다.

**HTTP/2.0에서 논의되는 7가지 기술**

HTTP/2.0은 주요한 7가지 기술에 대해서 논의되고 있는데 현 단계에서는 다음의 프로토콜에서 사용되고 있는 기술을 채택하자는 의견이 우세합니다. 그러나 아직 논의되고 있는 중이기 때문에 사양이 크게 바뀔 가능성도 있습니다.![스크린샷 2023-10-20 오후 3.54.35](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-20 오후 3.54.35.png)

### 웹 서버 상의 파일을 관리하는 WebDAV

WebDAV(Web-based Distributed Authoring and Versioning)는 웹 서버의 콘텐츠에 대해서, 직접 파일 복사나 편집 작업 등을 할 수 있는 분산 파일 시스템으로 HTTP/1.1를 확장한 프로토콜로 RFC4918로서 정의되어 있습니다. ㅏㅍ일 작성이나 삭제 등 기본적인 기능 이외에 파일 작성자 등의 관리나 편집중에 다른 유저가 다시 고쳐 쓰지 못하도록 잠금 기능, 갱신 정보를 관리하는 리비전 기능 등이 준비되어 있습니다. HTTP/1.1 의 PUT 메소드나 DELETE 메소드를 사용하면 웹 서버 상의 파일작성이나 삭제 등을 할 수 있지만 보안이나 편의성 등의 문제가 있어서 사용되고 있지 않습니다.

**HTTP/1.1을 확장한 WebDAV**

서버 상의 리소스에 대해서 WebDAV에 새롭게 추가한 개념으로서 다음과 같은 것이 있습니다.

- 컬렉션(Collection) : 여러 개의 리소스를 한꺼번에 관리하기 위한 개념입니다. 각종 조작은 컬렉션 단위로 할 수 있습니다. 컬렉션 속에 컬렉션을 두어 사용할 수도 있습니다.
- 자원(Resource) : 파일이나 컬렉션을 리소스라고 부릅니다.
- 프로퍼티(Property) : 리소스의 프로퍼티를 정의한 것입니다. 정의는 "이름=값"의 형식으로 이루어집니다.
- 잠금(Lock) : 파일을 편집할 수 없는 상태로 합니다. 여러 명의 사람이 동시에 편집하는 경우 등 동시에 작성되는 걸 예방합니다.

**WebDAV에서 추가된 메소드와 상태 코드**

WebDAV에서는 리모트 파일 관리를 위해서 HTTP/1.1에 다음의 메소드가 추가되어 있습니다.

- PROPFIND : 프로퍼티 취득
- PROPPATCH : 프로퍼티 변경
- MKCOL : 컬렉션 작성
- COPY : 리소스 및 프로퍼티 복제
- MOVE : 리소스 이동
- LOCK : 리소스 잠금
- UNLOCK : 리소스 잠금 해제

메소드의 확장에 맞춰서 상태 코드도 확장되어 있습니다.

- 102 Processing : 리퀘스트는 정상적으로 수신되었지만 아직 처리 중이다.
- 207 Multi-Status : 복수의 스테이터스를 가지고 있다.
- 422 Unprocessable Entity : 서식은 올바르지만 내용이 틀리다.
- 423 Locked : 리소스가 잠겨져 있다.
- 424 Failed Dependency : 어떤 리퀘스트와 관련된 리퀘스트가 실패했기 때문에 의존 관계를 유지 못한다.
- 507 Insufficient Storage : 기억 영역이 부족하다.

![스크린샷 2023-10-20 오후 4.59.30](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-20 오후 4.59.30.png)

![스크린샷 2023-10-20 오후 4.59.44](/Users/asthu/Desktop/스크린샷 2023-10-20 오후 4.59.44.png)
