### 2. HTTP 프로토콜의 구조

---

TCP/IP에 있는 다른 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버 간에 통신을 합니다. 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 됩니다.

경우에 따라서는 2대의 컴퓨터 간에 통신을 할 경우, 클라이언트와 서버가 바뀌는 일도 있을 수 있지만, 한 번 통신했을 때만 본다면 클라이언트와 서버의 역할은 반드시 정해져 있습니다. HTTP는 클라이언트와 서버의 역할을 명확하게 구별하고 있습니다.

**리퀘스트와 리스폰스를 교환하여 성립**

HTTP는 클라이언트로부터 리퀘스트(요청)가 송신되며, 그 결과가 서버로부터 리스폰스(응답)로 되돌아옵니다. 즉, 반드시 클라이언트 측으로부터 통신이 시작됩니다. 서버 측은 리퀘스트를 받지 않고서는 리스폰스를 송신하는 일은 없습니다.

아래는 클라이언트 측으로부터 HTTP 서버에 송신되었던 리퀘스트 내용입니다.

``` 
GET /index.html HTTP /1.1
Host: www.hackr.jp
```

먼저 "GET"은 서버에 요구하는 종류를 나타내고 있으며 메소드라고 불립니다. 다음 문자열 "/index.html"은 요구 대상인 리소스를 나타내고 있는데 리퀘스트 URI라고 합니다. 그리고 "HTTP/1.1"은 클라이언트 기능을 식별하기 위한 HTTP 버전 번호입니다. 즉, 여기서의 리퀘스트 내용은 HTTP 서버 상에 있는 "/index.html"라는 리소스가 필요하다는 리퀘스트입니다. 리퀘스트 메시지는 메소드, URI, 프로토콜 버전, 옵션 리퀘스트 헤더 필드와 엔티티로 구성되어 있습니다.

```
POST /form/entry HTTP/1.1
(메소드	/	URI	/	프로토콜 버전)/
Host: hackr.jp
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 16
(리퀘스트 헤더 필드)
					name=ueno&age=37
					(엔티티)
```

리퀘스트 헤더 필드와 엔티티에 대해서는 나중에 설명하도록 하겠습니다. 계속해서, 리퀘스트를 받은 서버는 리퀘스트 내용을 처리한 결과를 리스폰스로 클라이언트에 되돌려 줍니다.

```
HTTP /1.1 200 OK
(프로토콜 버전/ 상태코드,상태코드 설명)
Date: Tue, 10 Jul 2023 06:50:15 GMT
Content-Length: 362
Content-Type: text/html
(리스폰스 헤더 필드)
<html>
...
(바디)
```

첫 번째 줄을 보면 "HTTP/1.1"은 서버의 HTTP 버전을 나타내고 있습니다. 그리고 "200 OK"는 리퀘스트의 처리 결과를 나타내는 상태 코드와 설명입니다. 다음 줄은 리스폰스가 발생한 일시를 나타내고 있는데 헤더 필드라고 불리는 것 중 하나입니다. 그리고 빈 줄로 구분하는데 그 아래에 있는 부분이 바디(body)라고 불리는 리소스 본체가 됩니다. 기본적으로 리스폰스 메시지는 프로토콜 버전, 상태 코드(리퀘스트가 성공했는지 실패했는지 등을 나타내는 숫자 코드)와 그 상태 코드를 설명한 프레이즈. 옵션의 리스폰스 헤더 필드와 바디로 구성되어 있습니다. 상세한 내용에 대해서는 나중에 설명합니다.

**HTTP는 상태를 유지하지 않는 프로토콜**

HTTP는 상태를 계속 유지하지 않는 스테이트리스(stateless) 프로토콜입니다. HTTP 프로토콜 독자적으로, 리퀘스트와 리스폰스를 교환하는 동안에 상태(status, 스테이터스)를 관리하지 않습니다. 결국, HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않습니다. HTTP에서는 새로운 리퀘스트가 보내질 때 마다 새로운 리스폰스가 생성됩니다. 프로토콜로서는 과거의 리퀘스트나 리스폰스 정보를 전혀 가지고 있지 않습니다. 이는 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성(scalability)을 확보하기 위해서 이와 같이 간단하게 설계되어 있는 것입니다. 

그러나 웹이 진화함에 따라, 스테이트리스 특성만으로는 처리하기 어려운 일이 증가하게 되었습니다. 누가 어떤 리퀘스트를 보냈는지를 파악하기 위한 상태를 유지할 일이 생겼습니다. HTTP/1.1은 상태를 유지하지 않는 프로토콜입니다. 그래서 상태를 유지하고 싶은 요구에 부응하기 위해 쿠키(Cookie)라는 기술이 도입되었습니다. 쿠키로 인해 HTTP를 이용한 통신에서도 상태를 계속 관리할 수 있게 도었습니다. 쿠키에 대해서는 나중에 설명합니다.

**리퀘스트 URI로 리소스를 식별**

HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정합니다. 이 URI가 있는 덕분에 인터넷 사으이 어떤 장소에 있는 리소스도 호출할 수 있습니다. 클라이언트는 리소스를 호출할 때 마다 리퀘스트를 송신할 때에 리퀘스트 안에 URI를 리퀘스트 URI라고 불리는 형식으로 포함해야 할 필요가 있습니다. 리퀘스트 URI를 지정하는 방법에는 여러 종류가 있습니다.

- 모든 URI를 리퀘스트 URI에 포함한다

  ```
  GET http://hackr.jp/index.htm HTTP/1.1
  ```

- Host 헤더 필드에 네트워크 로케이션을 포함한다

  ```
  GET /index.htm HTTP/1.1
  Host: hackr.jp
  ```

이것 외에도 특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 리퀘스트 URI에 [*]을 지정할 수 있습니다. 아래는 HTTP 서버가 지원하고 있는 메소드를 묻는 예입니다.

```
OPTIONS * HTTP/1.1
```

**서버에 임무를 부여하는 HTTP 메소드**

이제 HTTP/1.1에서 사용할 수 있는 메소드에 대해서 설명해 보겠습니다.

- GET: 리소스 획득

  리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구합니다. 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과입니다. 결국 리소스가 텍스트이면 그대로 반환하고 CGI와 같은 프로그램이면 실행해서 출력된 내용을 돌려줍니다.

- POST: 엔티티 전송

  엔티티를 전송하기 위해서 사용됩니다. GET으로도 엔티티를 전송할 수 있지만, 자주 사용하지 않고 일반적으로 POST를 사용합니다. POST는 GET과 기능이 비슷하지만 리스폰스에 의한 엔티티를 획득하는 것만이 목적은 아닙니다.

- PUT: 파일 전송

  PUT 메소드는 파일을 전송하기 위해서 사용됩니다. FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구합니다. 단지, HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제도 있어서 일반적인 웹 사이트에서는 사용되지 않고 있습니다. 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST(Representational State Transfer)와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우가 있습니다.

- HEAD: 메시지 헤더 취득

  HEAD 메소드는 GET과 같은 기능이지만 메시지 바디는 돌려주지 않습니다. URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용됩니다.

- DELETE: 파일 삭제

  DELETE 메소드는 파일을 삭제하기 위해 사용됩니다. PUT 메소드와는 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구합니다. 단지, HTTP/1.1의 DELETE 자체에는 PUT 메소드와 같이 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되고 있지 않습니다. 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST를 사용하는 경우에 사용되는 경우가 있습니다.

- OPTIONS: 제공하고 있는 메소드의 문의

  OPTIONS 메소드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용됩니다.

- TRACE: 경로 조사

  TRACE 메소드는 Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킵니다. 리퀘스트를 보낼 때에 "Max-Forwards"라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때마다 그 수치를 줄여갑니다. 수치가 0이 된 곳을 끝으로, 리퀘스트를 마지막으로 수신한 곳에서 상태 코드 200 OK 리스폰스를 되돌려 줍니다. 클라이언트는 TRACE 메소드를 사용함으로써, 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있습니다. 이것이 프록시 등을 중계하여 오리진(origin) 서버에 접속할 때 그 동작을 확인하기 위해서 사용되고 있습니다. 다만, TRACE 메소드는 거의 사용되지 않는데다 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있기 때문에 보통은 사용되고 있지 않습니다.

- CONNECT: 프록시에 터널링 요구

  CONNECT 메소드는 프록시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해서 사용됩니다. 주로 SSL이랑 TLS 등의 프로토콜로 암호화 된 것을 터널링 시키기 위해 사용되고 있습니다. CONNECT 메소드의 양식은 다음과 같이 이루어져 있습니다

  ```
  CONNECT 프록시 서버 : 포트 HTTP 버전
  ```

**메소드를 사용해서 지시를 내리다**

리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우에는 메소드라고 불리는 명령이 있습니다. 메소드는 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재합니다. 

**지속 연결로 접속량을 절약**

HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었습니다.

![스크린샷 2023-08-03 오후 5.10.53](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-08-03 오후 5.10.53.png)

초기 당시의 통신에서는 작은 사이즈의 텍스트를 보내는 정도였기 때문에, 이렇게 기능을 구현해도 문제는 없었습니다. 그러나 HTTP가 널리 보급되어감에 따라, 다량의 이미지를 포함한 문서 등이 늘어났습니다.

![스크린샷 2023-08-03 오후 5.12.02](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-08-03 오후 5.12.02.png)

**지속 연결**

HTTP/1.1과 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해서 지속 연결(Persistent Connections)이라는 방법을 고안하였습니다. 지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지합니다.

![스크린샷 2023-08-03 오후 5.13.28](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-08-03 오후 5.13.28.png)

지속 연결을 하는 이점은 TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감됩니다. 또한, 오버헤드를 줄인 만큼 HTTP 리퀘스트와 리스폰스가 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있습니다. 이러한 지속 연결은 HTTP/1.1에서는 표준 동작이지만 HTTP/1.0에서는 정식 사양이 아니었습니다. 일부 서버에서는 사양에 없는 기능을 구현해서 지속 연결을 가능하게 한 것도 있지만 반드시 지속 연결이 지원되고 있다고는 할 수 없습니다. 물론, 클라이언트도 지속 연결을 지원할 필요가 있습니다.

**파이프라인화**

지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인(HTTP pipelining)화를 가능하게 합니다. 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있습니다. 이로 인해, 여러 리퀘스트를 병행해서 보내는 것이 가능하기 때문에 일일이 리스폰스를 기다릴 필요가 없습니다.

![스크린샷 2023-08-03 오후 5.16.27](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-08-03 오후 5.16.27.png)

**쿠키를 사용한 상태 관리**

HTTP는 스테이트리스 프로토콜입니다. 이점은 상태를 유지하지 않는다는 점에서 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있습니다. 또한, 단순한 프로토콜이기에 HTTP가 다양한 곳에서 이용되는 측면도 있습니다. 스테이트리스 프로토콜이라는 특징은 남겨둔 채, 로그인 상태같은 것을 지속할 수 없는 문제를 해결하기 위해 쿠키라는 시스템이 도입되었습니다. 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템입니다. 쿠키는 서버에서 리스폰스로 보내진 Set-Cookie 라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됩니다. 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신합니다. 서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인해서 이전 상태를 알 수 있습니다.

![스크린샷 2023-08-03 오후 5.21.38](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-08-03 오후 5.21.38.png)
