### HTTP의 약점

지금까지 HTTP의 좋은 점이나 편리한 점만을 다루어 왔지만, HTTP에 좋은점만 있는 것은 아닙니다. HTTP에도 약점이 있는데 HTTP는 주로 다음과 같은 약점을 가지고 있습니다.

- 평문(암호화 하지 않은) 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능

이 약점은 HTTP만이 아닌, 다른 암호화하지 않은 프로토콜에도 공통되는 문제입니다. 그 밖에도 HTTP 자신의 약점은 몇 가지 있습니다. 또, 특정 웹 서버나 특정 웹 클라이언트의 구현상의 약점(취약성 또는 시큐리티 홀이라고 합니다), Java나 PHP 등으로 구축한 웹 애플리케이션 취약성 등이 있습니다.

**평문이기 때문에 도청 가능**

HTTP를 사용한 리퀘스트나 리스폰스 통신 내용은 HTTP 자신을 암호화하는 기능은 없기 때문에 통신 전체가 암호화 되지는 않습니다. 즉, 평문(암호화 되지 않은 메시지)으로 HTTP 메시지를 보내게 됩니다.

- TCP/IP는 도청 가능한 네트워크

  어째서 암호화되어 있지 않은 통신에 약점이 있냐 하면 TCP/IP의 구조의 통신 내용은 전부 통신경로의 도중에 엿볼 수 있기 때문입니다. 인터넷은 전 세계를 경유하는 네트워크로 되어 있습니다. 어느 서버와 클라이언트가 통신을 할 때, 통신 경로 상에 있는 네트워크 기기나 케이블이나 컴퓨터 등을 전부 자기 자신이 소유하고 있는 일은 있을 수 없습니다. 그래서 악의를 가진 누군가가 엿 볼 수 있습니다. 통신 내용을 엿볼 수 있다는 것은, 암호화된 통신에서도 암호화되지 않은 통신도 같습니다. 암호화 통신은 메시지 속의 의미는 간파할 수 없을 수도 있겠지만 암호화된 메시지 자체는 엿볼 수 있습니다.

  같은 세그먼트의 통신을 도청하는 것은 어려운 일이 아닙니다. 네트워크 상을 흐르고 있는 패킷을 수집하는 것만으로 도청할 수 있게 됩니다. 패킷을 수집하려면 패킷을 해석하는 패킷 캡처나 스니퍼라는 툴을 사용합니다. 아래 화면은 자주 사용되고 있는 패킷 캡처인 [Wireshark] 라는 툴을 사용해서 HTTP를 사용한 리퀘스트와 리스폰스의 내용을 취득해서 해석한 것입니다. GET을 사용해서 리퀘스트를 하고 있는 모습과 그 리스폰스에 "200 OK"를 반환하고 리스폰스의 HTTP 메시지 내용이 전부 나타내고 있는 것을 알 수 있습니다.

- 암호화로 도청을 피하다

  현재 도청으부터 정보를 지키기 위한 방법이 몇 가지가 연구되고 있습니다. 그 중에서 가장 보급되어 있는 기술은 암호화입니다. 암호화에는 몇 가지의 대상이 있습니다.

 1. 통신 암호화

    한 가지는 통신을 암호화하는 방법입니다. HTTP에는 암호화 구조는 없지만 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있습니다. SSL 등을 이용해 안전한 통신로를 확립하고 나서 그 통신로를 사용해 HTTP 통신을 합니다. SSL을 조합한 HTTP를 HTTPS(HTTP Secure)나 HTTP over SSL이라 불리고 있습니다.

 2. 콘텐츠 암호화

    다른 한 가지는 통신하고 있는 콘텐츠의 내용 자체를 암호화해 버리는 방법입니다. HTTP에 암호화를 하는 기능은 없기 때문에 HTTP를 사용해서 운반하는 내용을 암호화하는 것입니다. 즉, HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것입니다. 이 경우, 클라이언트에서 HTTP 메시지를 암호화해서 출력하는 처리가 필요하게 됩니다. 물론, 콘텐츠의 암호화를 유효하게 하기 위해서는 클라이언트와 서버가 콘텐츠의 암호화나 복호화 구조를 가지고 있는 것이 전제가 되므로, 평상시에 유저가 사용하는 브라우저와 웹 서버에서는 이용하는 것은 어렵습니다. 주로 웹 서비스 등에서 이용되는 방법입니다.

**통신 상대를 확인하지 않기 때문에 위장 가능**

HTTP를 사용한 리퀘스트나 리스폰스에서는 통신 상대를 확인하지 않습니다. 리퀘스트를 보낸 서버가 정말로 URI에서 지정된 호스트인지 아닌지, 리스폰스를 반환한 클라이언트가 정말로 리퀘스트를 출력한 클라이언트인지 아닌지를 모른다는 것입니다.

- 누구나 리퀘스트할 수 있다

  HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기 때문에 누구든지 리퀘스트를 보낼 수 있습니다. 또한, 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환합니다(단, IP 주소나 포트 등에서 그 웹 서버에 액세스 제한이 없는 경우).

  HTTP는 누구이던 간에 리퀘스트를 보내면 리스폰스가 반환되는 매우 심플한 구조로 되어 있지만, 상대를 확인하지 않는 점이 약점일 수가 있습니다. 그 약점은 다음과 같습니다.

  - 리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지 아닌지를 확인할 수 없다. 위장한 웹 서버일 우려가 있다.
  - 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지 아닌지를 확인할 수 없다. 위장한 클라이언트일 우려가 있다.
  - 통신하고 있는 상대가 접근이 허가된 상대인지 아닌지를 확인할 수 없다. 중요한 정보를 가진 웹 서버에서는 특정 상대만 통신을 허가하고 싶을 때가 있다.
  - 어디의 누가 리퀘스트를 했는지를 확인할 수 없다.
  - 의미없는 리퀘스트라도 수신하게 된다. 대량의 리퀘스트에 의한 DoS 공격(서비스 불능 공격)을 방지할 수가 없다.

- 상대를 확인하는 증명서

  HTTP에서는 통신 상대를 확인할 수 없지만 SSL로 상대를 확인할 수 있습니다. SSL은 암호화뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있습니다. 증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명합니다. 또 그 증명서를 위조하는 것은 기술적으로 상당히 어렵습니다. 통신 상대의 서버나 클라이언트가 가진 증명서를 확인함으로써 통신 상대가 내가 통신하고자 하는 상대인지 아닌지를 판단할 수 있습니다. 이 증명서를 이용함으로써, 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 됩니다. 또한, 클라이언트가 증명서를 가짐으로써 본인 확인을 하고, 웹 사이트 인증에서 이용할 수도 있습니다.

  ![스크린샷 2023-09-19 오후 4.52.53](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-19 오후 4.52.53.png)

​	

**완전성을 증명할 수 없기 때문에 변조 가능**

완전성이란 정보의 정확성을 가리킵니다. 그것을 증명할 수 없다는 것은 정보가 정확한지 아닌지를 확인할 수 없음을 의미합니다.

- 수신한 내용이 다를지도 모른다

  HTTP가 완전성을 증명할 수 없다는 뜻은 만약 리퀘스트나 리스폰스가 발신된 후에 상대가 수신할 때까지의 사이에 변조되었다고 하더라도 이 사실을 알 수 없다는 뜻입니다. 즉, 발신된 리퀘스트나 리스폰스오 수신한 리퀘스트나 리스폰스가 같은지 아닌지를 확인할 수 없다는 의미입니다. 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle 공격)이라고 부릅니다.

- 변조를 방지하려면?

  HTTP를 사요해서 완전성을 확인하기 위한 방법은 있지만, 확실하면서 편리한 방법은 현재로서는 존재하지 않습니다. 그 중에서도 자주 사용되고 있는 방법은 MD5나 SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법입니다. 파일 다운로드 서비스를 제공하고 있는 웹 사이트에서는 PGP(Pretty Good Privacy)에 의한 서명과 MD5에 의한 해시 값을 제공하는 일이 있습니다. PGP는 파일을 작성했다는 증명을 위한 서명으로, MD5는 단방향성 함수에 의한 해시 값입니다. 어느 쪽을 사용하더라도 클라이언를 이용하고 있는 유저 자신이 다운로드 받은 파일을 토대로 검사할 필요가 있습니다. 브라우저에서 자동적으로 검사가 진행되는 것은 아닙니다. 그러나 아쉽게도 이 방법으로 확실히 확인할 수 있는 것은 아닙니다. 그것은 PGP와 MD5 자체도 적절하게 수정되어 있다고 한다면, 유저로서는 알 수가 없습니다. 확실히 방지하기에는 HTTPS를 사용할 필요가 있습니다. HTTP만으로는 완전성을 보증하는 것이 어렵기 때문에 다른 프로토콜을 조합함으로써 실현하고 있습니다.

### HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS

**HTTP에 암호화와 인증과 보호를 더한 HTTPS**

HTTP통신은 암호화되지 않은 평문으로 실시됩니다. 예를 들면 웹 페이지에서 신용 카드 번호를 입력했을 때 통신이 도청되면 신용 카드 번호를 도청당하게 됩니다. 또한, HTTP에는 통신 상대의 서버나 클라이언트를 인증하는 수단이 없습니다. 실제로는 의도한 통신 상대와 통신하고 있지 않을 가능성이 있습니다. 그리고 수신한 메시지가 도중에 변조되어 있을 가능성도 생각할 수 있습니다. 이러한 문제를 해결하기 위해서는 암호화와 인증과 완전성 보호 같은 구조를 HTTP에 추가할 필요가 있습니다. HTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS(HTTP Secure)라고 부릅니다.

![스크린샷 2023-09-19 오후 5.33.53](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-19 오후 5.33.53.png)

HTTPS를 사용하는 통신은 웹페이지의 로그인이나 쇼핑의 결제화면 등에서 사용되고 있습니다. HTTPS를 사용한 통신은 URI에 http://가 아닌 https://를 사용합니다. 또한, 브라우저에서 HTTPS가 유효한 웹 사이트에 액세스하면 자물쇠 마크가 표시되는 등 HTTP와는 다르게 표시되는 경우가 있습니다.

**HTTPS는 SSL의 껍질을 덮어쓴 HTTP**

HTTPS는 새로운 애플리케이션 계층의 프로토콜은 아닙니다. HTTP 통신을 하는 소켓 부분을 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는 프로토콜로 대체하고 있을 뿐입니다.

![스크린샷 2023-09-19 오후 5.41.27](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-19 오후 5.41.27.png)

보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용한 경우에는 HTTP는 SSL와 통신하고 SSL이 TCP와 통신하게 됩니다. 즉, SSL이라는 껍질을 덮어쓴 HTTP가 HTTPS인 것입니다. SSL을 사용함으로써 HTTP는 HTTPS로서 암호화와 증명서와 완전성 보호를 이용할 수 있게 됩니다. SSL은 HTTP와는 독립된 프로토콜로 HTTP만으로는 애플리케이션 계층에서 동작하는 SMTP나 Telnet 등에서도 이용될 수 있습니다. SSL은 현재 세계 어느 곳에서도 널리 사용되고 있는 네트워크 보안 기술이라고 말할 수 있습니다.

**상호간에 키를 교환하는 공개키 암호화 방식**

SSL을 설명하기 전에 암호화 방식에 대해서 설명합니다. SSL에서는 공개키 암호화 방식이라 불리는 암호화 방식을 채용하고 있습니다. 현대의 암호는 알고리즘이 공개되어 있고 키를 비밀에 부침으로써 안전성을 유지합니다. 암호화나 복호화할때 이 키를 사용합니다. 키가 없으면 암호를 풀 수는 없지만 반대로 생각해보면 키를 가지고 있다면 누구라도 암호를 풀 수가 있습니다. 공격자가 키를 알게 되면 암호화가 의미를 잃어버리게 됩니다.

- 공통키 암호의 딜레마

  암호화와 복호화에 하나의 키를 같이 사용하는 방식을 공통키 암호라고 부릅니다. 공통키 암호화 방식은 상대방에게 키를 넘겨주지 않으면 안됩니다. 그러나 어떻게 해서 안전하게 키를 상대에게 배송하면 좋을까요? 네트워크를 사용해서 키를 넘겨줄 때 통신이 도청되어 공격자에게 키를 빼앗기게 되면 암호화의 의미가 없게 되어 버립니다. 또한, 받은 키를 안전하게 보관하기 위한 노력을 하지 않으면 안됩니다.

  ![스크린샷 2023-09-22 오후 4.16.54](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-22 오후 4.16.54.png)

- 두 개의 키를 사용하는 공개키 암호

  공통키 암호의 문제를 해결하려고 한 것이 공개키 암호라는 방식입니다. 공개키 암호에서는 서로 다른 두 개의 키 페어(쌍)을 사용합니다. 한쪽은 비밀키(private key)라 부르고 다른 한쪽은 공개키(public key)라고 부릅니다. 이름대로, 비밀키는 누구에게도 알려지면 안되는 키이며 공개키는 누구에게나 알려져도 괜찮은 키입니다. 공개키 암호를 사용한 암호화는 암호를 보내는 측이 상대의 공개키를 사용해 암호화를 합니다. 그리고 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해 복호화를 실시합니다. 이 방식은 암호를 푸는 비밀키를 통신으로 보낼 필요가 없기 때문에 도청에 의해서 키를 빼앗길 걱정은 없습니다. 또, 암호문과 공개키라는 정보에서 평문을 구하는 것은 매우 어려운 수학적인 특징이 있기 때문에 간단하지는 않습니다. 만약 큰 수의 소인수 분해를 고속으로 할 수 있다면 해독할 수 있지만, 현재로선 쉽지 않습니다.
  
  ![스크린샷 2023-09-25 오후 4.51.19](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-25 오후 4.51.19.png)

- HTTPS는 하이브리드 암호 시스템

  HTTP는 공통키 암호와 공개키 암호의 양쪽 성질을 가진 하이브리드 암호 시스템입니다. 키를 안전하게 교환할 수만 있다면 공개키 암호만을 사용해서 통신을 해도 괜찮다고 생각할 지도 모르지만, 공개키 암호는 공통키 암호에 비해서 처리 속도가 늦습니다. 거기서 두 가지 장점을 살릴 수 있도록 각각의 방식을 조합해서 통신합니다. 키를 교환하는 곳에서는 공개키 암호를 사용하고 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용합니다.

  ![스크린샷 2023-09-26 오후 3.35.43](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-09-26 오후 3.35.43.png)

**공개키가 정확한지 아닌지를 증명하는 증명서**

아쉽게도 공개키 암호에도 문제점이 있습니다. 그 문제점은 공개키가 진짜인지 아닌지를 증명할 수 없다는 것입니다. 예를 들면, 어떤 서버와 공개키 암호를 사용해서 통신을 시작하려 할 때 수신한 공개키가 본래 의도한 서버가 발행한 공개키인지를 어떻게 증명할 수 있을까요? 도중에 공격자가 공개키를 바꿔치기 했을지도 모릅니다. 이 문제를 해결하는 데는 인증 기관(CA:Certificate Authority)과 그 기관이 발행하는 공개키 증명서가 이용되고 있습니다. 인증 기관이란 클라이언트와 서버가 모두 신뢰하는 제3자 기관입니다. 유명한 인증 기관에는 VeriSign사가 있습니다.

인증 기관은 다음과 같이 이용됩니다. 먼저 서버의 운영자가 인증 기관에 공개키를 제출합니다. 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만듭니다. 그리고 공개키 인증서에 서명이 끝난 공개키를 담습니다. 서버는 이 인증 기관에 의해서 작성된 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신을 합니다. 공개키 인증서는 디지털 증명서나 줄여서 증명서라고 부르는 경우도 있습니다. 증명서를 받은 클라이언트는 증명 기관의 공개키를 사용해서 서버의 공개키를 인증한 것이 진짜 인증 기관이라는 것과 서버의 공개키가 신뢰할 수 있다는 것을 알 수 있습니다. 여기에서 사용되는 인증 기관의 공개키는 안전하게 클라이언트에 전달되지 않으면 안됩니다. 통신중에는 어떤 방법을 사용하더라도 안전하게 전달하는 것은 어렵기 때문에 많은 브라우저가 주요 인증 기관의 공개키를 사전에 내장한 상태로 제품을 내놓고 있습니다.

- 조직의 실제성을 증명하는 EV SSL 증명서

  증명서의 역할은 서버가 올바른 통신 상대임을 증명하는 것이지만, 상대방이 실제로 있는 기업인지를 확인하는 역할도 있습니다. 그러한 역할을 가진 증명서를 EV SSL 증명서라고 합니다. EV SSL 증명서는 세계 표준의 인정 가이드라인에 의해서 발행되는 증명서입니다, 운영하는 조직의 실재성을 확인하는 방법을 엄격히 규정하고 있기 때문에 웹 사이트의 신뢰성을 더욱 더 높일 수 있습니다. 브라우저의 주소창의 색이 녹색으로 변하면 EV SSL 증명서로 증명된 웹 사이트인 것을 시각적으로 알 수 있습니다. 그리고 주소창의 옆에는 SSL 증명서에 기재되어 있는 조직명 및 증명서를 발행한 인증 기관 명이 표시됩니다. 이것은 피싱 사기 방지를 의도한 것이지만 효과가 있는지의 여부는 의문입니다. 많은 유저는 EV SSL 증명서를 알지 못하기 때문에 주의를 기울일 필요는 없을 듯 합니다.

- 클라이언트를 확인하는 클라이언트 증명서

  HTTPS에서는 클라이언트 증명서도 이용할 수 있습니다. 클라이언트 증명서를 이용하여 서버 증명서와 같이 서버가 통신하고 있는 상대가 의도한 클라이언트인 것을 증명하는 클라이언트 인증을 할 수 있습니다. 클라이언트 증명서는 몇가지 문제점이 있습니다. 먼저, 클라이언트 증명서에서 문제가 되는 점은 증명서의 입수와 배포입니다. 유저가 클라이언트 증명서를 인스톨할 필요가 있습니다. 클라이언트 증명서는 유료로 구입할 필요가 있기 때문에 유저 수만큼 비용이 들게 됩니다. 또한, 여러 유저가 인스톨 작업을 해야 하는 것도 큰 일입니다. 안전성이 매우 높은 인증 기능을 제공할 수 있지만 특정 용도로만 사용되는 실정입니다. 클라이언트 인증은 그 만큼 비용을 들일 필요가 있는 곳에서만 사용되고 있습니다. 예를 들면, 은행 인터넷 뱅킹에서 사용되는 경우가 있습니다. 로그인할 때 ID나 패스워드로 본인 확인을 할 뿐만 아니라 클라이언트 증명서를 요구하여 특정 단말기에서 액세스하는지 아닌지를 확인할 수 있습니다. 클라이언트 증명서의 또 다른 문제점은 클라이언트 인증서는 어디까지나 클라이언트의 실재를 증명할 뿐, 사용자의 존재 유무를 증명하는 증명서는 아닙니다. 즉, 클라이언트 증명서가 들어간 컴퓨터를 사용할 권한이 있다면 누구든지 클라이언트 증명서를 이용할 수 있다는 것입니다.

- 인증 기관은 신용이 제일

  SSL은 인증 기관을 신용할 수 있다는 전제로 이루어져 있습니다. 하지만 2011년 7월에 네덜란드의 DigiNotar라는 인증 기관이 잘못 액세스되어 "google.com"이나 "twitter.com" 등의 가짜 증명서가 발행되어 버린 사건이 발생했습니다. 이것은 SSL 신뢰의 근본이 흔들리는 사건이었습니다. 이렇게 잘못 발행된 증명서라고 해도 믿을수 있는 인증 기관은 서명이 있기 때문에 브라우저는 올바른 증명서로서 인식합니다. 서버로 위장할 때에 사용되더라도 유저가 알아채기 어렵습니다. 증명서를 무효화하는 증명서 취소 리스트(CRL)라는 구조나 루트 인증 기관을 클라이언트에서 삭제하는 대책이 있지만, 효과를 발휘할 때까지 시간이 걸리기 때문에 그 사이에 얼만만큼 유저가 피해를 입을지는 알 수 없습니다.

- 자기 인증 기관 발행 증명서는 '나야 나' 증명서

  OpenSSL 등의 소프트웨어를 사용하면 누구든지 인증 기관을 구축할 수 있어서 서버 증명서를 발행할 수 있습니다. 그러나 이 서버 증명서는 인터넷 상에서는 증명서로서 구실을 하지 못하며 쓸모가 없습니다. 독자적으로 구축한 인증 기관을 자기 인증 기관이라 부르고, 거기서 발행한 쓸모 없는 증명서를 비하해서 '나야 나 증명서'라고 부르는 일도 있습니다. 브라우저에 액세스하면 [접속의 안전성을 확인할 수 없습니다]나 [이 사이트의 보안 증명서에는 문제가 있습니다]등의 경고 메시지가 표시됩니다. 자기 인증 기관이 발행한 서버 증명서가 쓸모 없다는 것은, 위장의 가능성을 불식할 수 없기 때문입니다. 자기 인증 기관이기 때문에 스스로 [나는 00입니다]라고 자칭하고 있는 상태가 됩니다. '나야 나' 증명서를 사용하고 있더라도 SSL로 암호화하고 있기 때문에 통신은 안전하다는 설명을 가끔 볼 수 있는데 이것은 잘못된 것입니다. 통신은 암호화되어 있어도 위장하고 있는 가짜 서버와 통신하고 있을 가능성이 있습니다. 신뢰할 수 있는 제3자 기관이 인증하기 때문에 브라우저에 내장된 인증 기관의 공개키가 가능하게 되고 그 서버의 증명이 가능하게 되는 것입니다.

  **마이너 인증 기관을 사용하면 '나야 나' 증명서가 될 수도 있다**

  많은 브라우저에 내장된 메이저 인증 기관도 있지만 경우에 따라서는 일부 브라우저에만 포함된 마이너 인증 기관도 있습니다. 그러한 인증 기관이 발행한 서버 증명서는 어떤 브라우저에서 정규 증명서로서 취급되더라도 다른 브라우저에서는 '나야 나' 증명서로서 취급될 수도 있습니다.

**안전한 통신을 하는 HTTPS의 구조**

HTTPS를 이해하기 위해서 통신의 수순을 살펴 보도록 합시다.![스크린샷 2023-10-13 오후 3.25.16](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-13 오후 3.25.16.png)

1. 클라이언트가 Client Hello 메시지를 송신하면서 SSL 통신을 시작합니다. 메시지에는 클라이언트가 제공하는 SSL의 버전을 지정하고, 암호 스위트(Cipher Suite)로 불리는 리스트(사용하는 암호화의 알고리즘이나 키 사이즈 등) 등이 포함되어 있습니다.
2. 서버가 SSL 통신이 가능한 경우에는 Server Hello 메시지로 응답합니다. 클라이언트와 같이 SSL 버전과 암호 스위트를 포함합니다. 서버의 암호 스위트 내용은 클라이언트에서 받은 암호 스위트의 내용에서 선택된 것입니다.
3. 서버가 Certificate 메시지를 송신합니다. 메시지에는 공개키 증명서가 포함되어 있습니다.
4. 서버가 Server Hello Done 메시지를 송신하여 최초의 SSL 네고시에이션 부분이 끝났음을 통지합니다.
5. SSL의 최초 네고시에이션이 종료되면 클라이언트가 Client Key Exchange 메시지로 응답합니다. 메시지에는 통신을 암호화하는데 사용하는 Pre-Master secret이 포함되어 있습니다. 이 메시지는 3의 공개키 증명서에서 꺼낸 공개키로 암호화되어 있습니다.
6. 클라이언트는 Change Cipher Spec 메시지를 송신합니다. 이 메시지는 이 메시지 이후의 통신은 암호키를 사용해서 진행한다는 것을 나타내고 있습니다.
7. 클라이언트는 Finished 메시지를 송신합니다. 이 메시지는 접속 전체의 체크 값을 포함하고 있습니다. 네고시에이션이 성공했는지 어떤지는 서버가 이 메시지를 올바르게 복호화할 수 있는지 아닌지가 결정됩니다.
8. 서버에서도 마찬가지로 Change Cipher Spec 메시지를 송신합니다.
9. 서버에서도 마찬가지로 Finished 메시지를 송신합니다.
10. 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속은 확립됩니다. 물론 통신은 SSL에 의해서 보호되고 있습니다. 이제부터는 애플리케이션 계층의 프로토콜에 의해 통신을 합니다. 즉, HTTP 리퀘스트를 송신합니다.
11. 애플리케이션 계층의 프로토콜에 의한 통신입니다. 즉, HTTP 리스폰스를 송신합니다.
12. 마지막에 클라이언트가 접속을 끊습니다. 접속을 끊을 경우에는 close_notify 메시지를 송신합니다. 그림에서는 생략되었지만, 그 후에 TCP FIN 메시지를 보내 TCP 통신을 종료합니다.

이 흐름에 더해서, 애플리케이션 계층의 데이터를 송신할 때에는 MAC(Message Authentication Code)이라고 부르는 메시지 다이제스트를 덧붙일 수도 있습니다. MAC을 이용해서 변조를 감지할 수 있어서 완전성 보호를 실현할 수 있습니다. 이 흐름을 그림으로 나타내면 다음과 같이 됩니다. 그림은 서버 측의 공개키 증명서(서버 증명서)만을 이용한 HTTPS에 의한 통신을 시작하여 HTTP에 의한 통신을 개시하는 곳까지의 설명입니다.

![스크린샷 2023-10-13 오후 4.24.27](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-13 오후 4.24.27.png)

- SSL과 TLS

  HTTPS에서는 SSL(Secure Socket Layer)과 TLS(Transport Layer Security)라는 두개의 프로토콜이 사용되고 있습니다. SSL은 본래 브라우저 개발 회사였던 넷스케이프 커뮤니케이션스사가 내놓은 프로토콜로 SSL3.0 까지는 같은 회사에서 개발되었습니다. SSL3.0을 기반으로 한 TLS1.0이 책정되어 TLS1.1, TLS1.2가 있습니다. TLS는 SSL을 바탕으로 한 프로토콜이지만, 이 프로토콜을 총칭해서 SSL이라고 부르기도 합니다. 현재는 SSL3.0, TLS1.0이 주류입니다. SSL1.0 프로토콜은 설계시점에서 문제가 발견되었기 때문에 실제로 사용되지는 않았습니다. SSL2.0이라는 프로토콜에서도 문제가 발견되었기 때문에 많은 브라우저에서는 무효화되고 있습니다.

- SSL은 느리다?

  HTTPS에도 문제가 있습니다. 바로 SSL를 사용하면 처리가 늦어지게 된다는 점입니다.

  ![스크린샷 2023-10-13 오후 4.27.39](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-13 오후 4.27.39.png)SSL 통신이 지연되는 이유에는 두 가지가 있습니다. 하나는 통신속도가 떨어지는 것과, 다른 하나는 CPU나 메모리 등의 리소스를 다량으로 소비함으로써 처리가 느려지는 것입니다. 네트워크의 부하는 HTTP를 사용하는 경우에 비해 2배에서 100배 정도 느려질 수 있습니다. TCP 접속과 HTTP의 리퀘스트/리스폰스 이외에 SSL에 필요한 통신이 추가되기 때문에 전체적으로 처리해야 할 통신이 증가해 버립니다. 다른 하나는 SSL은 반드시 암호화 처리를 하고 있기 때문에 서버나 클라이언트에서는 암호화나 복호화를 위한 계산을 할 필요가 있습니다. 그렇기 때문에 서버나 클라이언트의 리소스를 소비하게 되어 HTTP에 비해 부담이 커집니다. 느려지는 것에 대한 근본적인 해결 방법은 없기 때문에, SSL 엑셀레이터라는 하드웨어(appliance 서버)를 사용해서 이 문제를 해결하기도 합니다. SSL 엑셀레이터는 SSL을 처리하기 위한 전용 하드웨어로 소프트웨어로 SSL을 처리할 때보다 몇 배 빠른 계산을 할 수 있습니다. SSL의 처리만 SSL 엑셀레이터에 맡김으로써 부하를 분산하도록 하고 있습니다.

**왜 항상 HTTPS를 사용하지 않는가?**

HTTPS가 안정하다면 왜 모든 웹 사이트는 항상 HTTPS를 계속해서 사용하지 않는 것일까요? 그 이유 중 하나는 평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스가 많이 필요하기 때문입니다. 통신할 때마다 암호화를 하면 많은 리소스를 소비하기 때문에 그 결과 한 대당 처리할 수 있는 리퀘스트의 수가 줄어들게 됩니다. 그렇기 때문에 민감한 정보를 포함하지 않는 통신에서는 HTTP를 사용하고 개인 정보 등 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용합니다. 특히 액세스가 많은 웹 사이트 등에서 암호화를 하면 그 부하가 상당합니다. 암호화를 사용하는 경우에는 모든 콘텐츠를 암호화하는 것이 아니라 숨겨야 할 정보만 암호화함으로써 리소스를 절약하고 있습니다. 그 외에는 증명서를 구입하는 비용을 절약하고 싶다는 이유가 있습니다. HTTPS를 사용하기 위해서는 증명서가 필요하지만, 이를 사용하기 위해서는 CA에서 증명서를 구입해야 합니다. 가격은 사업자에 따라 다르지만, 일반적으로 년간 수십만 원 정도 필요하게 됩니다. 증명서의 구입 비용이 부담되는 서비스나 개인적인 웹 사이트 등에서는 HTTP만 선택하는 경우도 있습니다.

